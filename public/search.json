[
  {
    "id": "2025年终总结",
    "title": "2025 年终总结",
    "summary": "2025 生活、工作、学习",
    "content": "距离下班还有 1 小时，我开始写这篇年终总结。\n回看这一年，主要想从生活、工作、学习三个方面做个梳理。\n生活\n家庭与角色变化\n2025 年，家里最大的变化是老婆开始创业，以及带娃。\n原本以为创业后老婆的时间会更自由，实际却更不确定，甚至比上班更忙。晚上忙到十点、十一点成了常态。创业带来的情绪波动也很明显：视频爆了、突然有订单会让人很兴奋；但如果连续几周甚至一个多月没起色，情绪难免低落。\n最近又碰上家人生病住院，这件事让我重新意识到：健康永远是那个\"1\"，其他都是后面的\"0\"。可以为了目标拼，但人不是机器，身体和心理状态都要持续关注。系统都知道做监控，人更应该给自己做监控。\n带娃与自我反思\n在带娃这件事上，我投入得不够，主要还是双方父母在承担。\n我现在对\"鸡娃\"这件事没有太强执念。AI 发展这么快，未来不至于饿肚子，或许没必要卷得那么狠。\n带娃本身也是认识自己的过程：当你有足够多的\"控制权\"，你会怎么用？自己小时候不喜欢经历的事情，能不能尽量不让孩子重复？\n我回想自己的童年，除了不太让我打游戏，整体其实挺快乐。今天正好刷到陈行甲老师的育儿课程，准备过年期间认真看看。\n健康与运动\n我在 2025 年重新开始跑步，主要在健身房。真的是\"不跑不知道，一跑吓一跳\"。\n跟刚毕业时 56 分钟跑 19 公里相比，现在状态差很多；尤其想把心率控制在 150 以下，难度非常大。\n不过跑步的效果很直接：体重从巅峰 88kg 降到大约 81kg。离标准体重还有距离，但在持续进步。\n跑步不追求竞速，更多是为了提升自我控制能力。\n当然，减重更高效的方法是控制饮食——但我暂时不想，嘿嘿。\n消费复盘\n2025 年整体开支不小。除了日常薅羊毛买一些杂物，也入手了几个大件。主观体验如下：\n大路灯：还行\n扫地机器人：不满意，已退\n上下水洗地机：真香\n亚瑟士跑步鞋：真香\n座椅垫：真香\n4K 显示器：真香\n行车记录仪：还行\n胎压监测仪：还行\n单人躺椅：真香\n降噪耳机：真香\n---\n工作\n这一年工作上的变化也很大：从\"正规军外包\"转到\"草台班子自研\"。薪水涨了一些，但加班时长也明显拉满。表面看起来还不错，但我越来越强烈地感到\"有力使不上\"。\n过去没认真想过的问题，今年都摆到了台面上：\n怎么证明一件事有价值、值得付费？\n   我写过一份很完整的 AI 辅助编程收益报告给领导，但最终还是没争取到经费。\n怎么合理",
    "tags": [
      "My Summary"
    ],
    "date": "2026-02-14",
    "readingTime": "8 min read",
    "url": "/blog/2025年终总结",
    "searchText": "2025 年终总结 距离下班还有 1 小时 我开始写这篇年终总结 回看这一年 主要想从生活 工作 学习三个方面做个梳理 生活 家庭与角色变化 2025 年 家里最大的变化是老婆开始创业 以及带娃 原本以为创业后老婆的时间会更自由 实际却更不确定 甚至比上班更忙 晚上忙到十点 十一点成了常态 创业带来的情绪波动也很明显 视频爆了 突然有订单会让人很兴奋 但如果连续几周甚至一个多月没起色 情绪难免低落 最近又碰上家人生病住院 这件事让我重新意识到 健康永远是那个 1 其他都是后面的 0 可以为了目标拼 但人不是机器 身体和心理状态都要持续关注 系统都知道做监控 人更应该给自己做监控 带娃与自我反思 在带娃这件事上 我投入得不够 主要还是双方父母在承担 我现在对 鸡娃 这件事没有太强执念 AI 发展这么快 未来不至于饿肚子 或许没必要卷得那么狠 带娃本身也是认识自己的过程 当你有足够多的 控制权 你会怎么用 自己小时候不喜欢经历的事情 能不能尽量不让孩子重复 我回想自己的童年 除了不太让我打游戏 整体其实挺快乐 今天正好刷到陈行甲老师的育儿课程 准备过年期间认真看看 健康与运动 我在 2025 年重新开始跑步 主要在健身房 真的是 不跑不知道 一跑吓一跳 跟刚毕业时 56 分钟跑 19 公里相比 现在状态差很多 尤其想把心率控制在 150 以下 难度非常大 不过跑步的效果很直接 体重从巅峰 88kg 降到大约 81kg 离标准体重还有距离 但在持续进步 跑步不追求竞速 更多是为了提升自我控制能力 当然 减重更高效的方法是控制饮食 但我暂时不想 嘿嘿 消费复盘 2025 年整体开支不小 除了日常薅羊毛买一些杂物 也入手了几个大件 主观体验如下 大路灯 还行 扫地机器人 不满意 已退 上下水洗地机 真香 亚瑟士跑步鞋 真香 座椅垫 真香 4K 显示器 真香 行车记录仪 还行 胎压监测仪 还行 单人躺椅 真香 降噪耳机 真香 工作 这一年工作上的变化也很大 从 正规军外包 转到 草台班子自研 薪水涨了一些 但加班时长也明显拉满 表面看起来还不错 但我越来越强烈地感到 有力使不上 过去没认真想过的问题 今年都摆到了台面上 怎么证明一件事有价值 值得付费 我写过一份很完整的 AI 辅助编程收益报告给领导 但最终还是没争取到经费 怎么合理评估工时 同一个任务 不同领导对难度判断差异很大 如何更有效地沟通和说服 是我今年最头疼的问题之一 理论上相似模块会越做越快 但再快也有极限 不可能真变成 一小时一个模块 的流水线 时间 范围 资源 领导都要时怎么办 在我看来 这个问题在现实里往往无解 至少不可能长期成立 怎么证明自己的价值 要不要证明 这件事分两层 对内 向当前同事和领导证明 对外 向未来的面试官证明 形式可能是开源 工具项目 或其他可被看见的成果 怎么带好前端团队 怎么做好跨部门协作 虽然我离管理岗还有距离 但看着当前团队的管理方式 更能理解 正规军 在制度和流程上的价值 它确实让人安心 这些问题都没有标准答案 AI 可以提供行动建议 但真正要走出来 还是得靠自己找到可执行的方法 学习 今年我想学的东西很多 英语 ERP 业务 跑步训练 育儿 但时间始终有限 我现在更理解 机会成本 这件事 你做的每个选择 都会放弃其他可能性 在学校里的学习相对简单 考核标准清晰 分数直接反馈掌握程度 而成年后的学习更像一场没有终点的马拉松 你可以休息 甚至会倒退 但最终还是要继续向前 对新年的期待 家人健康第一 年后安排老婆爸妈做一次完整体检 有问题尽早处理 我自己爸妈也继续保持年度体检 日常营养方面 当前在吃的鱼油可以补货 也给自己定一个原则 只要身体不舒服 先停下手头其他事 优先处理健康问题 跑步目标 10 公里控制在 1 小时 15 分钟内 心率尽量保持在 150 以下 支持老婆做想做的事 无论是继续小生意 去画画 还是其他方向 我都尽力支持 让小米更多接触真实世界 少看手机 不只是孩子 家里所有人都一起执行 把工作问题理清楚 再决定去留 在 忍 与 滚 之间 不急着情绪化决策 先想清楚 换一家公司 这些问题就一定会消失吗 有没有可能在当前环境里找到改进路径 2025年到站了 地铁也到站了 我现在坐在雨山路地铁站外面的座椅上 敲下这些文字 祝大家新年快乐 身体健康 祝世界和平"
  },
  {
    "id": "Async-Await",
    "title": "Async/Await",
    "summary": "async/await 是什么？ \"async/await 是 JavaScript 处理异步操作（如网络请求、文件读取）的\"语法糖\"，它让我们能用写同步代码的方式写异步逻辑，避免层层嵌套的回调函数。 底层依赖 Generator 的暂停/恢复机制和 Promise 的状态管理，async 函数总返回 Promise，即使内部返回普通值也会被自动包装为 Promise.resolve(value)...",
    "content": "async/await 是什么？\n\"async/await 是 JavaScript 处理异步操作（如网络请求、文件读取）的\"语法糖\"，它让我们能用写同步代码的方式写异步逻辑，避免层层嵌套的回调函数。\n底层依赖 Generator 的暂停/恢复机制和 Promise 的状态管理，async 函数总返回 Promise，即使内部返回普通值也会被自动包装为 Promise.resolve(value)\nawait 仅暂停当前 async 函数内的代码，不阻塞 JavaScript 主线程（其他同步任务照常执行），这是通过微任务队列实现的。\n为什么要有这个？\n让开发者可以通过看起来同步的方式，执行异步任务\n它是怎么实现的？\n最佳实践\n一定要加 try catch ，做错误处理和捕获\n出错时，提供给用户清晰的错误原因和下一步能做的措施",
    "tags": [
      "JavaScript",
      "Async/Await"
    ],
    "date": "2025-10-27",
    "readingTime": "3 min read",
    "url": "/blog/Async-Await",
    "searchText": "Async Await async await 是什么 async await 是 JavaScript 处理异步操作 如网络请求 文件读取 的 语法糖 它让我们能用写同步代码的方式写异步逻辑 避免层层嵌套的回调函数 底层依赖 Generator 的暂停 恢复机制和 Promise 的状态管理 async 函数总返回 Promise 即使内部返回普通值也会被自动包装为 Promise resolve value await 仅暂停当前 async 函数内的代码 不阻塞 JavaScript 主线程 其他同步任务照常执行 这是通过微任务队列实现的 为什么要有这个 让开发者可以通过看起来同步的方式 执行异步任务 它是怎么实现的 最佳实践 一定要加 try catch 做错误处理和捕获 出错时 提供给用户清晰的错误原因和下一步能做的措施"
  },
  {
    "id": "BFC",
    "title": "BFC（Block-Formatting-Context）-块级格式化上下文",
    "summary": "接下来将会更新一系列文章，每篇文章将会聚焦一个概念，从以下四个角度回答问题：是什么？如何创建（使用）？解决了什么问题？最佳实践有哪些？这是系列的第一篇，关于 BFC。 BFC 是什么？ BFC 全称是（Block-Formatting-Context）块级格式化上下文，BFC内部的块级盒子会在垂直方向上一个接一个地放置，属于同一个BFC的两个相邻Box的垂直margin会发生重叠。BFC就是页面上...",
    "content": "接下来将会更新一系列文章，每篇文章将会聚焦一个概念，从以下四个角度回答问题：是什么？如何创建（使用）？解决了什么问题？最佳实践有哪些？这是系列的第一篇，关于 BFC。\nBFC 是什么？\nBFC 全称是（Block-Formatting-Context）块级格式化上下文，BFC内部的块级盒子会在垂直方向上一个接一个地放置，属于同一个BFC的两个相邻Box的垂直margin会发生重叠。BFC就是页面上的一个隔离的独立容器，容器内部的子元素不会影响外层样式，外层样式也无法影响容器内层样式，BFC的区域不会与浮动元素（float box）发生重叠。\n如何创建 BFC？\n 标签本身就是一个 BFC\n设置 overflow：hidden/auto/scroll\n设置 display：flex/grid/inline-block/flow-root/inline-flex/inline-grid/table-cell\n设置 position：absolute/fixed\n设置 float 不是 none，即 left/right\nBFC 解决了什么问题？\n全部子元素都设置 float 后，造成的父元素高度塌陷。BFC可以包含浮动元素，使得计算BFC的高度时，浮动元素的高度也参与计算，从而避免了高度塌陷。\n在同一个 BFC 中，相邻块级元素的 margin 合并问题\n当左侧 float+固定宽度，右侧自适应宽度布局时，会出现悬浮元素遮盖问题\n文本环绕问题\nBFC 最佳实践有哪些？\n优先使用 flex/grid 等现代布局方法，如果仅为了实现 BFC，可以优先考虑 display：flow-root，避免 overflow： hidden 造成的裁切问题\n在处理 margin 合并问题时，无需让相邻的元素都构建 BFC，只需要给其中一个加上就行\n扩展内容\nBFC (块级格式化上下文)、FFC (弹性格式化上下文)、GFC (网格布局格式化上下文)、IFC (行内格式化上下文)\n处理历史布局问题​：对于需要清除浮动、防止外边距合并或处理文字环绕等经典问题，​BFC 依然是直接有效的解决方案。在现代布局中，它更像一个精细的调整工具\n安排组件内部布局​：对于组件内部的一维线性布局，比如导航栏、工具条、卡片列表等，​FFC​（Flexbox布局）通常更简单灵活。它在内容动态分布和对齐方面表现",
    "tags": [
      "CSS",
      "BFC"
    ],
    "date": "2025-10-20",
    "readingTime": "8 min read",
    "url": "/blog/BFC",
    "searchText": "BFC Block Formatting Context 块级格式化上下文 接下来将会更新一系列文章 每篇文章将会聚焦一个概念 从以下四个角度回答问题 是什么 如何创建 使用 解决了什么问题 最佳实践有哪些 这是系列的第一篇 关于 BFC BFC 是什么 BFC 全称是 Block Formatting Context 块级格式化上下文 BFC内部的块级盒子会在垂直方向上一个接一个地放置 属于同一个BFC的两个相邻Box的垂直margin会发生重叠 BFC就是页面上的一个隔离的独立容器 容器内部的子元素不会影响外层样式 外层样式也无法影响容器内层样式 BFC的区域不会与浮动元素 float box 发生重叠 如何创建 BFC 标签本身就是一个 BFC 设置 overflow hidden auto scroll 设置 display flex grid inline block flow root inline flex inline grid table cell 设置 position absolute fixed 设置 float 不是 none 即 left right BFC 解决了什么问题 全部子元素都设置 float 后 造成的父元素高度塌陷 BFC可以包含浮动元素 使得计算BFC的高度时 浮动元素的高度也参与计算 从而避免了高度塌陷 在同一个 BFC 中 相邻块级元素的 margin 合并问题 当左侧 float 固定宽度 右侧自适应宽度布局时 会出现悬浮元素遮盖问题 文本环绕问题 BFC 最佳实践有哪些 优先使用 flex grid 等现代布局方法 如果仅为了实现 BFC 可以优先考虑 display flow root 避免 overflow hidden 造成的裁切问题 在处理 margin 合并问题时 无需让相邻的元素都构建 BFC 只需要给其中一个加上就行 扩展内容 BFC 块级格式化上下文 FFC 弹性格式化上下文 GFC 网格布局格式化上下文 IFC 行内格式化上下文 处理历史布局问题 对于需要清除浮动 防止外边距合并或处理文字环绕等经典问题 BFC 依然是直接有效的解决方案 在现代布局中 它更像一个精细的调整工具 安排组件内部布局 对于组件内部的一维线性布局 比如导航栏 工具条 卡片列表等 FFC Flexbox布局 通常更简单灵活 它在内容动态分布和对齐方面表现出色 构建整体页面结构 当需要设计复杂的二维布局 如整个页面的头部 主体 侧边栏和底部区域 并且需要同时精确控制行和列时 应优先选择 GFC Grid布局 它提供了最强大的布局能力 理解行内元素排版 IFC 的概念虽然不常直接使用 但理解它有助于更好地控制文本和行内元素的垂直对齐 行高等细节"
  },
  {
    "id": "HTTP",
    "title": "HTTP",
    "summary": "HTTP是超文本传输协议，HTTP1.1，HTTP2，HTTP3分别代表三个版本，可用于前后端数据通信。 升级后，优化了哪些功能？解决了哪些问题？ 1. HTTP1.1 时期，默认复用TCP连接（持久连接），请求必须按照顺序响应，会造成队头阻塞。浏览器最多支持 6 个 TCP 连接。重复传输了头部字段，无优先级控制。 2. 从 HTTP1.1，升级到 HTTP 2 后，通过二进制分帧和多路复用的能...",
    "content": "HTTP是超文本传输协议，HTTP1.1，HTTP2，HTTP3分别代表三个版本，可用于前后端数据通信。\n升级后，优化了哪些功能？解决了哪些问题？\nHTTP1.1 时期，默认复用TCP连接（持久连接），请求必须按照顺序响应，会造成队头阻塞。浏览器最多支持 6 个 TCP 连接。重复传输了头部字段，无优先级控制。\n从 HTTP1.1，升级到 HTTP 2 后，通过二进制分帧和多路复用的能力，解决应用层阻塞问题（TCP 仍阻塞），可以并行处理的请求数量大大增加。支持了头部压缩（HPACK）算法减少体积和服务器推送功能。底层仍依赖 TCP，丢包时所有流会受阻塞（原因是HTTP2 的多路复用仍依赖 TCP按序传输的特性，单个丢包会导致整个连接等待重传）\n从 HTTP2 升级到 HTTP3，使用了一种名为 QUIC 的协议（基于 UDP 而不是TCP），每个流独立传输，彻底解决队头阻塞问题，使用了新的头部压缩（QPACK）算法，0-RTT握手（首次连接也只需要 1 次握手），内置 TLS 加密，支持断网续传\n如何升级？\nhttp2 需后端服务器配置新协议（Nginx中配置listen 443 ssl http2，并启用TLS 1.2+）\nhttp3 需开启 QUIC 支持（Nginx 1.25+配置listen 443 quic，添加Alt-Svc头，实现与HTTP/2的优雅降级） ，前端需在升级后验证兼容性，资源加载顺序是否有影响（可以减少资源合并，比如之前合并的大的 css 文件，可以考虑做拆分，提高效率），升级后可以通过查看控制台网络面板的 protocol 列查看协议\n最佳实践？\n至少升级到 HTTP2，且开启 https 加密，后期转向 HTTP3（尤其适合音视频游戏-降低延迟，移动网络环境-切换不断线）",
    "tags": [
      "HTTP",
      "Network"
    ],
    "date": "2025-10-21",
    "readingTime": "3 min read",
    "url": "/blog/HTTP",
    "searchText": "HTTP HTTP是超文本传输协议 HTTP1 1 HTTP2 HTTP3分别代表三个版本 可用于前后端数据通信 升级后 优化了哪些功能 解决了哪些问题 HTTP1 1 时期 默认复用TCP连接 持久连接 请求必须按照顺序响应 会造成队头阻塞 浏览器最多支持 6 个 TCP 连接 重复传输了头部字段 无优先级控制 从 HTTP1 1 升级到 HTTP 2 后 通过二进制分帧和多路复用的能力 解决应用层阻塞问题 TCP 仍阻塞 可以并行处理的请求数量大大增加 支持了头部压缩 HPACK 算法减少体积和服务器推送功能 底层仍依赖 TCP 丢包时所有流会受阻塞 原因是HTTP2 的多路复用仍依赖 TCP按序传输的特性 单个丢包会导致整个连接等待重传 从 HTTP2 升级到 HTTP3 使用了一种名为 QUIC 的协议 基于 UDP 而不是TCP 每个流独立传输 彻底解决队头阻塞问题 使用了新的头部压缩 QPACK 算法 0 RTT握手 首次连接也只需要 1 次握手 内置 TLS 加密 支持断网续传 如何升级 http2 需后端服务器配置新协议 Nginx中配置listen 443 ssl http2 并启用TLS 1 2 http3 需开启 QUIC 支持 Nginx 1 25 配置listen 443 quic 添加Alt Svc头 实现与HTTP 2的优雅降级 前端需在升级后验证兼容性 资源加载顺序是否有影响 可以减少资源合并 比如之前合并的大的 css 文件 可以考虑做拆分 提高效率 升级后可以通过查看控制台网络面板的 protocol 列查看协议 最佳实践 至少升级到 HTTP2 且开启 https 加密 后期转向 HTTP3 尤其适合音视频游戏 降低延迟 移动网络环境 切换不断线"
  },
  {
    "id": "HTTP缓存",
    "title": "HTTP缓存",
    "summary": "HTTP缓存，当浏览器访问一个网站时，会把页面上的图片，css 数据下载到本地，当用户下次再访问这个页面时，浏览器就可以直接读取本地副本，避免重复加载。主要分为强缓存和协商缓存，可以用来减少网络请求，提高用户体验。 怎么做到的？ 1. 浏览器发出 GET 请求后，先看下是否存在强缓存？ 2. 如果强缓存有效，则直接读取浏览器本地缓存 200 from cache 3. 如果强缓存失效，则考虑协商缓...",
    "content": "HTTP缓存，当浏览器访问一个网站时，会把页面上的图片，css 数据下载到本地，当用户下次再访问这个页面时，浏览器就可以直接读取本地副本，避免重复加载。主要分为强缓存和协商缓存，可以用来减少网络请求，提高用户体验。\n怎么做到的？\n浏览器发出 GET 请求后，先看下是否存在强缓存？\n如果强缓存有效，则直接读取浏览器本地缓存 200 from cache\n如果强缓存失效，则考虑协商缓存（浏览器要携带资源身份证，向服务器验证）\n查看上次请求响应头上是否有 ETag 字段？\n如果有 Etag，则发起请求头上携带 If-None-Match 服务器验证资源是否可用，如果可用，则返回 304 not modified（浏览器可以使用本地缓存的文件），如果不可用，则发出正常请求\n如果没有 Etag 字段，则查看上次请求响应头上是否有 Last-Modified 字段，如果有，则发起请求头上携带 If-Modified-Since 服务器验证资源是否可用，如果可用，则返回 304 Not Modified（浏览器可以使用本地缓存的文件），如果不可用，则发出正常请求\n相关的响应头字段\nCache-Control：\nmax-age：缓存存储最大时长，单位是 s\ns-max-age：缓存存储最大时长，单位是 s，仅用于代理服务器\npublic：响应可以被任意对象缓存\nprivate：只能被私有对象缓存，不能被代理服务器缓存\nno-cache：禁用强缓存，可走协商缓存（用前必须验证）\nno-store：禁用一切缓存\nExpires：服务端返回的资源过期时间，使用本地时间做判断，优先级低于 Cache-control: max-age，已经被逐渐替代。\nETag/If-None-Match​：资源的唯一标识哈希值，验证精度高\nLast-Modified/If-Modified-Since​：资源的最后修改时间戳\n浏览器本地缓存的优先级\nService Worker（可拦截请求）> memory cache（内存） > disk cache（硬盘） > Push Cache（推送缓存，http2）\n解决了什么问题？\n对用户来说：大幅提升页面加载速度，节省流量\n对服务器来说：显著降低服务器压力，提升网站高并发能力\n最佳实践是什么？\n静态资源使用强缓存并设置较长过期时间（如1年）。同时，在构建工具",
    "tags": [
      "HTTP",
      "Network",
      "Cache"
    ],
    "date": "2025-10-21",
    "readingTime": "4 min read",
    "url": "/blog/HTTP缓存",
    "searchText": "HTTP缓存 HTTP缓存 当浏览器访问一个网站时 会把页面上的图片 css 数据下载到本地 当用户下次再访问这个页面时 浏览器就可以直接读取本地副本 避免重复加载 主要分为强缓存和协商缓存 可以用来减少网络请求 提高用户体验 怎么做到的 浏览器发出 GET 请求后 先看下是否存在强缓存 如果强缓存有效 则直接读取浏览器本地缓存 200 from cache 如果强缓存失效 则考虑协商缓存 浏览器要携带资源身份证 向服务器验证 查看上次请求响应头上是否有 ETag 字段 如果有 Etag 则发起请求头上携带 If None Match 服务器验证资源是否可用 如果可用 则返回 304 not modified 浏览器可以使用本地缓存的文件 如果不可用 则发出正常请求 如果没有 Etag 字段 则查看上次请求响应头上是否有 Last Modified 字段 如果有 则发起请求头上携带 If Modified Since 服务器验证资源是否可用 如果可用 则返回 304 Not Modified 浏览器可以使用本地缓存的文件 如果不可用 则发出正常请求 相关的响应头字段 Cache Control max age 缓存存储最大时长 单位是 s s max age 缓存存储最大时长 单位是 s 仅用于代理服务器 public 响应可以被任意对象缓存 private 只能被私有对象缓存 不能被代理服务器缓存 no cache 禁用强缓存 可走协商缓存 用前必须验证 no store 禁用一切缓存 Expires 服务端返回的资源过期时间 使用本地时间做判断 优先级低于 Cache control max age 已经被逐渐替代 ETag If None Match 资源的唯一标识哈希值 验证精度高 Last Modified If Modified Since 资源的最后修改时间戳 浏览器本地缓存的优先级 Service Worker 可拦截请求 memory cache 内存 disk cache 硬盘 Push Cache 推送缓存 http2 解决了什么问题 对用户来说 大幅提升页面加载速度 节省流量 对服务器来说 显著降低服务器压力 提升网站高并发能力 最佳实践是什么 静态资源使用强缓存并设置较长过期时间 如1年 同时 在构建工具 如Webpack 中为文件名添加哈希值 如main a1b2c3 js 这样一旦资源内容变化 文件名就改变 从而强制浏览器下载新文件 既利用了缓存的速度 又能保证用户获取最新内容 html页面一般使用协商缓存 如Cache Control no cache 确保内容更新 f5 刷新时 浏览器会跳过强缓存 但可能进行协商缓存验证 ctrl f5 刷新 则会去掉所有缓存 直接向服务器发送接口请求 在开发阶段 可以开启浏览器控制台的停用缓存 避免影响"
  },
  {
    "id": "Promise",
    "title": "Promise",
    "summary": "什么是 Promise ? Promise 是 es6 提出的处理异步任务的\"承诺容器\"。它只有三个状态 pending，fulfilled，rejected，状态一旦从 pending 变成后面两个，就不会再发生变化了，支持链式调用，通过.then() 方法，可以将异步任务的结果参数传递下去，实现了更好的异步任务执行控制和错误处理。 为什么要有 Promise？解决了什么问题？ 在 Promis...",
    "content": "什么是 Promise ?\nPromise 是 es6 提出的处理异步任务的\"承诺容器\"。它只有三个状态 pending，fulfilled，rejected，状态一旦从 pending 变成后面两个，就不会再发生变化了，支持链式调用，通过.then() 方法，可以将异步任务的结果参数传递下去，实现了更好的异步任务执行控制和错误处理。\n为什么要有 Promise？解决了什么问题？\n在 Promise 之前，为了处理 JavaScript 中的异步任务，一般都是通过在回调函数中，拿到异步任务的结果，然后再进行下一步操作。如果涉及多个异步任务嵌套的场景，就会出现\"嵌套地狱\"。Promise 将嵌套的回调拍平了，可以竖着发展，而不是横向发展。\n核心机制？\n状态驱动：Promise 内部维护状态机，成功时调用 resolve(value)，失败时调用 reject(error)\n链式传递：每个 .then 方法都会返回一个新的 Promise，可以传递值或者 Promise 对象，实现任务的串联（.then ,.catch 里面都是 微任务，可以在当前宏任务结束后，立即执行，从而让用户更快的看到由异步任务触发的结果，比如渲染了新的数据之类）\n错误冒泡：在链中的任意环节，出现错误(throw new Error())，或者出现 reject(error)时，都会跳过后续的 .then，直达最近的 .catch\n如何实现 Promise？核心在于实现 .then 方法\n最基础实现\n一个包含了状态和错误处理的实现\nTODO：完整实现\n最佳实践\n能并行的，就并行，Promise.all([])\n一定要有 catch 做错误捕获处理\n可以使用 Promise.race 实现调用接口超时时间的控制\n针对Promise 中的接口请求，可能会存在竞态（即第一次请求返回比较慢，第二次请求返回比较快，导致页面上的数据渲染实际渲染了第一次的返回内容），此时如果是 fetch 这种支持请求终止的，就直接终止前一次的请求。如果是不支持请求终止的，比如 axios，可以加一个变量控制，在请求拿到数据后，通过变量看下当前所在的上下文是否已经销毁了？如果已经销毁了，那就啥也不做。如果没有销毁，就正常执行流程",
    "tags": [
      "JavaScript",
      "Promise"
    ],
    "date": "2025-10-27",
    "readingTime": "6 min read",
    "url": "/blog/Promise",
    "searchText": "Promise 什么是 Promise Promise 是 es6 提出的处理异步任务的 承诺容器 它只有三个状态 pending fulfilled rejected 状态一旦从 pending 变成后面两个 就不会再发生变化了 支持链式调用 通过 then 方法 可以将异步任务的结果参数传递下去 实现了更好的异步任务执行控制和错误处理 为什么要有 Promise 解决了什么问题 在 Promise 之前 为了处理 JavaScript 中的异步任务 一般都是通过在回调函数中 拿到异步任务的结果 然后再进行下一步操作 如果涉及多个异步任务嵌套的场景 就会出现 嵌套地狱 Promise 将嵌套的回调拍平了 可以竖着发展 而不是横向发展 核心机制 状态驱动 Promise 内部维护状态机 成功时调用 resolve value 失败时调用 reject error 链式传递 每个 then 方法都会返回一个新的 Promise 可以传递值或者 Promise 对象 实现任务的串联 then catch 里面都是 微任务 可以在当前宏任务结束后 立即执行 从而让用户更快的看到由异步任务触发的结果 比如渲染了新的数据之类 错误冒泡 在链中的任意环节 出现错误 throw new Error 或者出现 reject error 时 都会跳过后续的 then 直达最近的 catch 如何实现 Promise 核心在于实现 then 方法 最基础实现 一个包含了状态和错误处理的实现 TODO 完整实现 最佳实践 能并行的 就并行 Promise all 一定要有 catch 做错误捕获处理 可以使用 Promise race 实现调用接口超时时间的控制 针对Promise 中的接口请求 可能会存在竞态 即第一次请求返回比较慢 第二次请求返回比较快 导致页面上的数据渲染实际渲染了第一次的返回内容 此时如果是 fetch 这种支持请求终止的 就直接终止前一次的请求 如果是不支持请求终止的 比如 axios 可以加一个变量控制 在请求拿到数据后 通过变量看下当前所在的上下文是否已经销毁了 如果已经销毁了 那就啥也不做 如果没有销毁 就正常执行流程"
  },
  {
    "id": "React中的key",
    "title": "React中的key",
    "summary": "key 是什么？ 是一个特殊属性，主要针对列表，map 后的 react 组件，以及相邻的同类型 DOM，需要手动指定 key，帮助 react 做区分 为什么要有 key？ 1. React Diff 算法的需要。如果修改数组，没有指定 key 时，React 的 Diff 算法（优先通过 key 匹配），只能退化为按索引顺序对比。 2. 提升性能，比如说我在列表的开头新增了一个元素，如果不指定...",
    "content": "key 是什么？\n是一个特殊属性，主要针对列表，map 后的 react 组件，以及相邻的同类型 DOM，需要手动指定 key，帮助 react 做区分\n为什么要有 key？\nReact Diff 算法的需要。如果修改数组，没有指定 key 时，React 的 Diff 算法（优先通过 key 匹配），只能退化为按索引顺序对比。\n提升性能，比如说我在列表的开头新增了一个元素，如果不指定 key 的话，会让列表中原有的元素误以为内容发生了变化，导致整体重建（组件实例可能会被不必要的重新创建，、不仅仅是 UI 层更新，还会带来额外的性能开销，并可能引发子组件生命周期异常-子组件是PureComponent类型的可能不会更新）\n指定key能确保状态和正确元素绑定，是 React 识别和匹配\"组件实例\"的唯一标识，如果不指定 key，可能会发生数据错乱，以及重新渲染后导致的 Focus 丢失。比如有一个列表，map 后的数据有 输入框（带有默认值），一共有三项，如果你删除第二项，会发现此时第二项里面输入框里的默认值是之前删除的那一项里，输入框的默认值\n最佳实践\n如果直接使用数组循环中的 index 除了消除控制台警告，并没有其他任何好处，应该使用稳定（在整个生命周期内）的且唯一的 key（不需要全局唯一，只需要在兄弟元素中唯一），比如用户 id\n如果数据没有 id，可以先生成稳定标识（比如哈希值），避免使用随机数或时间戳，会造成额外重建",
    "tags": [
      "react",
      "react diff"
    ],
    "date": "2025-10-24",
    "readingTime": "3 min read",
    "url": "/blog/React中的key",
    "searchText": "React中的key key 是什么 是一个特殊属性 主要针对列表 map 后的 react 组件 以及相邻的同类型 DOM 需要手动指定 key 帮助 react 做区分 为什么要有 key React Diff 算法的需要 如果修改数组 没有指定 key 时 React 的 Diff 算法 优先通过 key 匹配 只能退化为按索引顺序对比 提升性能 比如说我在列表的开头新增了一个元素 如果不指定 key 的话 会让列表中原有的元素误以为内容发生了变化 导致整体重建 组件实例可能会被不必要的重新创建 不仅仅是 UI 层更新 还会带来额外的性能开销 并可能引发子组件生命周期异常 子组件是PureComponent类型的可能不会更新 指定key能确保状态和正确元素绑定 是 React 识别和匹配 组件实例 的唯一标识 如果不指定 key 可能会发生数据错乱 以及重新渲染后导致的 Focus 丢失 比如有一个列表 map 后的数据有 输入框 带有默认值 一共有三项 如果你删除第二项 会发现此时第二项里面输入框里的默认值是之前删除的那一项里 输入框的默认值 最佳实践 如果直接使用数组循环中的 index 除了消除控制台警告 并没有其他任何好处 应该使用稳定 在整个生命周期内 的且唯一的 key 不需要全局唯一 只需要在兄弟元素中唯一 比如用户 id 如果数据没有 id 可以先生成稳定标识 比如哈希值 避免使用随机数或时间戳 会造成额外重建"
  },
  {
    "id": "React中的useEffect",
    "title": "React中的useEffect",
    "summary": "1. 在单次渲染的范围内，props和state始终保持不变，可以看成固定值，在任何地方读取都是一样的（Capture Value） 2. React只会在浏览器绘制后运行effects。这使得你的应用更流畅因为大多数effects并不会阻塞屏幕的更新。Effect的清除同样被延迟了。上一次的effect会在重新渲染后被清除。 3. useEffect 里的 return，清理的也是当前渲染的这一...",
    "content": "在单次渲染的范围内，props和state始终保持不变，可以看成固定值，在任何地方读取都是一样的（Capture Value）\nReact只会在浏览器绘制后运行effects。这使得你的应用更流畅因为大多数effects并不会阻塞屏幕的更新。Effect的清除同样被延迟了。上一次的effect会在重新渲染后被清除。\nuseEffect 里的 return，清理的也是当前渲染的这一次的，它所在的上下文环境就在当前渲染这一次\nuseEffect使你能够根据props和state\\_同步\\_React tree之外的东西（也就是\"副作用\"），比如接口请求，浏览器 tab 标题等。\n针对依赖项，请保持诚实，最好在项目的一开始，就做出强制规定（通过 eslint 配置）\n在 useEffect 中，对于依赖旧 state 数据做更新 state 操作时，可以把 state 放入依赖，也可以使用 setState 的函数写法（更推荐，因为可以避免反复执行 effect）\n如果有多个依赖项？如何简化？\n使用 useReducer，将多个依赖项，合成一个对象去处理\ndispatch的时候，React只是记住了action\n它会在下一次渲染中再次调用reducer。在那个时候，新的props就可以被访问到，而且reducer调用也不是在effect里。\n它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必要的依赖，避免不必要的effect调用\n函数要不要放在 useEffect 里？从减少依赖的角度这么做也不错，或者你只把函数中真正依赖的变量，放在 useEffect 的依赖项中，也没问题啦\n如果你不想把函数放在 useEffect 里面，有两个方法：\n这个函数不依赖这个组件里的任何东西（比如一个工具函数？），那就直接把它放在组件外，然后直接在 useEffect 中调用就可以\n如果这个函数确实也依赖这个组件里的变量，那可以加一层 useCallback，并把这个函数的依赖补充完整，同时将这个函数作为依赖项放入 useEffect 的依赖项数组里面（useMemo 也可以做类似的事情）\n可能涉及到的 竞态，比如我有一个输入框，里面可以根据我输入的内容实时搜索一些数据，当我搜索 A 时，假如接口返回很慢，当请求还在后端处理的时候，我把搜索内容改为了 B ，此时接口很快就返",
    "tags": [
      "react",
      "useEffect"
    ],
    "date": "2025-10-24",
    "readingTime": "6 min read",
    "url": "/blog/React中的useEffect",
    "searchText": "React中的useEffect 在单次渲染的范围内 props和state始终保持不变 可以看成固定值 在任何地方读取都是一样的 Capture Value React只会在浏览器绘制后运行effects 这使得你的应用更流畅因为大多数effects并不会阻塞屏幕的更新 Effect的清除同样被延迟了 上一次的effect会在重新渲染后被清除 useEffect 里的 return 清理的也是当前渲染的这一次的 它所在的上下文环境就在当前渲染这一次 useEffect使你能够根据props和state _同步 _React tree之外的东西 也就是 副作用 比如接口请求 浏览器 tab 标题等 针对依赖项 请保持诚实 最好在项目的一开始 就做出强制规定 通过 eslint 配置 在 useEffect 中 对于依赖旧 state 数据做更新 state 操作时 可以把 state 放入依赖 也可以使用 setState 的函数写法 更推荐 因为可以避免反复执行 effect 如果有多个依赖项 如何简化 使用 useReducer 将多个依赖项 合成一个对象去处理 dispatch的时候 React只是记住了action 它会在下一次渲染中再次调用reducer 在那个时候 新的props就可以被访问到 而且reducer调用也不是在effect里 它可以把更新逻辑和描述发生了什么分开 结果是 这可以帮助我移除不必要的依赖 避免不必要的effect调用 函数要不要放在 useEffect 里 从减少依赖的角度这么做也不错 或者你只把函数中真正依赖的变量 放在 useEffect 的依赖项中 也没问题啦 如果你不想把函数放在 useEffect 里面 有两个方法 这个函数不依赖这个组件里的任何东西 比如一个工具函数 那就直接把它放在组件外 然后直接在 useEffect 中调用就可以 如果这个函数确实也依赖这个组件里的变量 那可以加一层 useCallback 并把这个函数的依赖补充完整 同时将这个函数作为依赖项放入 useEffect 的依赖项数组里面 useMemo 也可以做类似的事情 可能涉及到的 竞态 比如我有一个输入框 里面可以根据我输入的内容实时搜索一些数据 当我搜索 A 时 假如接口返回很慢 当请求还在后端处理的时候 我把搜索内容改为了 B 此时接口很快就返回了数据 前端也把它渲染在了页面上 那么等搜索内容 A 返回的时候 前端又一次把新数据渲染了一遍 最终看到的效果就是 我明明在搜索 B 但页面上展示的是 A 的搜索结果 如果你使用的是 fetch 这种 支持请求取消的 那很好 直接取消上一次请求就可以 如果是 axios 这种不支持取消的 最简单的解决方法 就是在修改 state 数据之前加个判断 看看后来有没有触发过新的请求 或者自己所在的这一次上下文 是不是已经被销毁了 如果是的话 就把修改 state 数据的逻辑忽略掉 请对比以下两段代码 如果 useEffect 不指定依赖项时 跟直接放在外面也是有区别的 直接放在外面时 这段代码会在渲染期间同步执行 会阻塞渲染 每次渲染都会执行 放在 useEffect 里面时 会在渲染结束后 立即执行 不会阻塞渲染 在每次渲染完成后都会执行 TODO 扩展内容 https overreacted io how are function components different from classes https segmentfault com a 1190000020964640 https zhuanlan zhihu com p 103150605 utm_source wechat_session https zhuanlan zhihu com p 106665408"
  },
  {
    "id": "React事件",
    "title": "React事件",
    "summary": "React 事件是什么？ React 事件是 React 框架对于浏览器原生事件的一层封装，称为合成事件，相当于一个事件综合处理系统。在页面上点击一个按钮时，浏览器会产生一个原生的事件，React 并不会给每一个按钮都加一个单独的监听器，而是在整个组件树的顶部（根 DOM 节点）设立一个调度中心。事件会冒泡到顶部，React 随后会创建一个合成事件对象，这个对象抹平了不同编辑器之间的差异，提供了一...",
    "content": "React 事件是什么？\nReact 事件是 React 框架对于浏览器原生事件的一层封装，称为合成事件，相当于一个事件综合处理系统。在页面上点击一个按钮时，浏览器会产生一个原生的事件，React 并不会给每一个按钮都加一个单独的监听器，而是在整个组件树的顶部（根 DOM 节点）设立一个调度中心。事件会冒泡到顶部，React 随后会创建一个合成事件对象，这个对象抹平了不同编辑器之间的差异，提供了一套统一的属性和方法。（比如都用 e.preventDefault()阻止默认事件 ），最后，React会根据事件最初发生的来源（event.target），精准地调用你在相应组件（例如）中定义的那个事件处理函数\n为什么需要 React 事件？作用是什么？\n跨浏览器的兼容性，确保在任何浏览器中都有一致的行为\n性能优化。通过事件委托机制，无论页面中有多少个支持交互的元素，React 都只需要在根 DOM 节点注册少量的监听器。减少了内存占用，提升了性能\n更好的开发体验和控制力。提供了统一的事件对象，可以与 React 组件化思想和虚拟 DOM 更新无缝集成，使得事件处理更容易编写和维护\n最佳实践？\n优先使用合成事件\n避免在渲染中创建新函数，比如在函数式组件中，JSX 中直接使用箭头函数，可能会导致子组件的不必要渲染，建议使用 useCallback 缓存一下\n正确阻止事件：阻止冒泡（e.stopPropagation()），阻止默认行为（e.preventDefault()）\n谨慎混用 React 事件和浏览器原生事件，如果确实需要直接使用原生事件的时候，需要在 useEffect 中进行事件监听，并在清理函数中移除监听，避免内存泄漏",
    "tags": [
      "react"
    ],
    "date": "2025-10-29",
    "readingTime": "3 min read",
    "url": "/blog/React事件",
    "searchText": "React事件 React 事件是什么 React 事件是 React 框架对于浏览器原生事件的一层封装 称为合成事件 相当于一个事件综合处理系统 在页面上点击一个按钮时 浏览器会产生一个原生的事件 React 并不会给每一个按钮都加一个单独的监听器 而是在整个组件树的顶部 根 DOM 节点 设立一个调度中心 事件会冒泡到顶部 React 随后会创建一个合成事件对象 这个对象抹平了不同编辑器之间的差异 提供了一套统一的属性和方法 比如都用 e preventDefault 阻止默认事件 最后 React会根据事件最初发生的来源 event target 精准地调用你在相应组件 例如 中定义的那个事件处理函数 为什么需要 React 事件 作用是什么 跨浏览器的兼容性 确保在任何浏览器中都有一致的行为 性能优化 通过事件委托机制 无论页面中有多少个支持交互的元素 React 都只需要在根 DOM 节点注册少量的监听器 减少了内存占用 提升了性能 更好的开发体验和控制力 提供了统一的事件对象 可以与 React 组件化思想和虚拟 DOM 更新无缝集成 使得事件处理更容易编写和维护 最佳实践 优先使用合成事件 避免在渲染中创建新函数 比如在函数式组件中 JSX 中直接使用箭头函数 可能会导致子组件的不必要渲染 建议使用 useCallback 缓存一下 正确阻止事件 阻止冒泡 e stopPropagation 阻止默认行为 e preventDefault 谨慎混用 React 事件和浏览器原生事件 如果确实需要直接使用原生事件的时候 需要在 useEffect 中进行事件监听 并在清理函数中移除监听 避免内存泄漏"
  },
  {
    "id": "React的数据存在哪里？",
    "title": "React中的数据存在哪里？",
    "summary": "先介绍两个概念 - 状态共位：将状态尽可能放置在离其使用位置最近的组件中。从而减少不必要的渲染和 props 传递，简化组件结构，提高可维护性。适用于状态仅被单个或少数几个组件使用的场景 - 状态提升：将共享状态提升到共同的祖先组件中。实现多个组件之间状态共享，父组件通过 props 向下传递数据和回调函数。使用于状态被多个兄弟组件所需要时。 一句话总结：共置状态 -> 提升状态 -> 组件组合 ...",
    "content": "先介绍两个概念\n状态共位：将状态尽可能放置在离其使用位置最近的组件中。从而减少不必要的渲染和 props 传递，简化组件结构，提高可维护性。适用于状态仅被单个或少数几个组件使用的场景\n状态提升：将共享状态提升到共同的祖先组件中。实现多个组件之间状态共享，父组件通过 props 向下传递数据和回调函数。使用于状态被多个兄弟组件所需要时。\n一句话总结：共置状态 -> 提升状态 -> 组件组合 -> Context\n首先考虑放在当前组件的 state 里面\n如果存在多个兄弟组件的状态都是同一个，那就提升到共同的父级组件中管理\n如果存在 props 多级传递，且中间层可能并不关心 props 状态，仅为了传递给深层组件，那么考虑直接将包含数据的深层组件，整个传递给子级（通过 props.children 或其它插槽的方式）\n最后考虑 context（redux）之类的全局状态管理器\n最佳实践：\n如果有多个状态需要一起同步，先观察下是否可以使用派生状态（即从现有 props 和 state 直接推导出新的状态），如果不行，考虑使用 useReducer\n针对计算成本很高的函数，可以在调用时使用 useMemo 包裹，缓存计算结果",
    "tags": [
      "react",
      "data location"
    ],
    "date": "2025-10-24",
    "readingTime": "2 min read",
    "url": "/blog/React的数据存在哪里？",
    "searchText": "React中的数据存在哪里 先介绍两个概念 状态共位 将状态尽可能放置在离其使用位置最近的组件中 从而减少不必要的渲染和 props 传递 简化组件结构 提高可维护性 适用于状态仅被单个或少数几个组件使用的场景 状态提升 将共享状态提升到共同的祖先组件中 实现多个组件之间状态共享 父组件通过 props 向下传递数据和回调函数 使用于状态被多个兄弟组件所需要时 一句话总结 共置状态 提升状态 组件组合 Context 首先考虑放在当前组件的 state 里面 如果存在多个兄弟组件的状态都是同一个 那就提升到共同的父级组件中管理 如果存在 props 多级传递 且中间层可能并不关心 props 状态 仅为了传递给深层组件 那么考虑直接将包含数据的深层组件 整个传递给子级 通过 props children 或其它插槽的方式 最后考虑 context redux 之类的全局状态管理器 最佳实践 如果有多个状态需要一起同步 先观察下是否可以使用派生状态 即从现有 props 和 state 直接推导出新的状态 如果不行 考虑使用 useReducer 针对计算成本很高的函数 可以在调用时使用 useMemo 包裹 缓存计算结果"
  },
  {
    "id": "React组件如何设计？",
    "title": "React组件如何设计？",
    "summary": "四点建议： 1. 一开始不要过度考虑组件的扩展性。如果在一开始就把各种情况都考虑到，会导致组件核心功能不清晰，为了实现各个 props，可能会导致代码存在很多的逻辑判断 2. 如果为了高扩展性设计，可以考虑更多使用 props.children 插槽的方式，让外界更自由的使用。而组件只关心自己的核心功能。如果是为了让用户即插即用，可能确实需要支持更多的 props。 3. 关注传入 props 的...",
    "content": "四点建议：\n一开始不要过度考虑组件的扩展性。如果在一开始就把各种情况都考虑到，会导致组件核心功能不清晰，为了实现各个 props，可能会导致代码存在很多的逻辑判断\n如果为了高扩展性设计，可以考虑更多使用 props.children 插槽的方式，让外界更自由的使用。而组件只关心自己的核心功能。如果是为了让用户即插即用，可能确实需要支持更多的 props。\n关注传入 props 的命名，类型，是否必填（使用 Typescript 强定义）\n关注组件中的状态管理，state => common parent state => props.children => context\n一个 Button 组件的示例\n功能：包含文字描述和图标，支持 Link（React Router） 和 a 标签\n注意点\n能够接受任意 props，例如 onKeyDown 和 aria-describedby\n能够呈现为 button 、带有 href 属性的 a 或带有 to 属性的 Link\n确保根元素具有其所需的所有 props，并且没有不支持的 props\n不会让 TypeScript 崩溃\n  我们来提供一个初始化示例\n在第一版的实现中我是这么做的\n但是还有几个小问题需要解决一下\n   使用交叉类型 &来合并多个不同的 HTML 元素类型（如 HTMLButtonElement、HTMLAnchorElement）的主要问题在于，它会试图创建一个同时包含所有这些元素属性的“超级”类型。这会导致几个问题：\n属性冲突与类型不兼容​：不同的 HTML 元素虽然有大量共用属性，但也存在许多独有的属性，甚至同名的属性可能要求不同的类型。例如，标签有 href 属性，而 有 disabled属性。当它们被合并时，您的组件理论上会同时拥有这些属性，这听起来很好，但实际上，当您将 ...rest属性传递给一个具体的 DOM 元素（如 ）时，href属性对按钮是无效的，可能会被 React 忽略或导致控制台警告。更重要的是，如果不同元素对同一个属性的类型定义存在不兼容（虽然不常见），交叉类型会尝试合并它们，可能导致该属性的类型变为 never，从而无法使用。\n语义混乱​：一个组件应该具有明确的语义。它应该清晰地对应一个主要的 HTML 元素。将一个组件的属性同时定义为按钮、链接和 div 的特性，会使",
    "tags": [
      "react",
      "react component"
    ],
    "date": "2025-10-24",
    "readingTime": "8 min read",
    "url": "/blog/React组件如何设计？",
    "searchText": "React组件如何设计 四点建议 一开始不要过度考虑组件的扩展性 如果在一开始就把各种情况都考虑到 会导致组件核心功能不清晰 为了实现各个 props 可能会导致代码存在很多的逻辑判断 如果为了高扩展性设计 可以考虑更多使用 props children 插槽的方式 让外界更自由的使用 而组件只关心自己的核心功能 如果是为了让用户即插即用 可能确实需要支持更多的 props 关注传入 props 的命名 类型 是否必填 使用 Typescript 强定义 关注组件中的状态管理 state common parent state props children context 一个 Button 组件的示例 功能 包含文字描述和图标 支持 Link React Router 和 a 标签 注意点 能够接受任意 props 例如 onKeyDown 和 aria describedby 能够呈现为 button 带有 href 属性的 a 或带有 to 属性的 Link 确保根元素具有其所需的所有 props 并且没有不支持的 props 不会让 TypeScript 崩溃 我们来提供一个初始化示例 在第一版的实现中我是这么做的 但是还有几个小问题需要解决一下 使用交叉类型 来合并多个不同的 HTML 元素类型 如 HTMLButtonElement HTMLAnchorElement 的主要问题在于 它会试图创建一个同时包含所有这些元素属性的 超级 类型 这会导致几个问题 属性冲突与类型不兼容 不同的 HTML 元素虽然有大量共用属性 但也存在许多独有的属性 甚至同名的属性可能要求不同的类型 例如 标签有 href 属性 而 有 disabled属性 当它们被合并时 您的组件理论上会同时拥有这些属性 这听起来很好 但实际上 当您将 rest属性传递给一个具体的 DOM 元素 如 时 href属性对按钮是无效的 可能会被 React 忽略或导致控制台警告 更重要的是 如果不同元素对同一个属性的类型定义存在不兼容 虽然不常见 交叉类型会尝试合并它们 可能导致该属性的类型变为 never 从而无法使用 语义混乱 一个组件应该具有明确的语义 它应该清晰地对应一个主要的 HTML 元素 将一个组件的属性同时定义为按钮 链接和 div 的特性 会使组件的用途和预期行为变得模糊不清 不利于代码的维护和理解 我们可以考虑使用 as 属性 实现多态组件 应该精确过滤和传递属性 如果你有更好的设计思路 欢迎和我交流"
  },
  {
    "id": "check-whether-the-file-in-jif-format",
    "title": "Check whether the file is in .jif format.",
    "summary": "使用 JavaScript 检查文件是否为 JFIF 格式的方法，通过读取文件头部的 JFIF 签名来验证图像格式",
    "content": "",
    "tags": [
      "IMG",
      "WEB",
      ".jif"
    ],
    "date": "2024-09-05",
    "readingTime": "1 min read",
    "url": "/blog/check-whether-the-file-in-jif-format",
    "searchText": "Check whether the file is in jif format"
  },
  {
    "id": "convert-the-React-SVG-component-into-a-Base64-URL",
    "title": "Convert the React SVG component into a Base64 URL",
    "summary": "One way to convert the React SVG component into a real DOM element and then into a Base64 URL",
    "content": "When working with React and third-party modules, some modules may not accept SVG as React components directly. In such cases, you need to convert the React SVG component into a real DOM element and then into a Base64 URL.",
    "tags": [
      "IMG",
      "WEB",
      "BASE64",
      "SVG"
    ],
    "date": "2024-08-29",
    "readingTime": "2 min read",
    "url": "/blog/convert-the-React-SVG-component-into-a-Base64-URL",
    "searchText": "Convert the React SVG component into a Base64 URL When working with React and third party modules some modules may not accept SVG as React components directly In such cases you need to convert the React SVG component into a real DOM element and then into a Base64 URL"
  },
  {
    "id": "debugging-a-mysterious-eslint-error",
    "title": "Debugging a Mysterious ESLint Error",
    "summary": "The error message displayed in my terminal was as follows: <tsconfigRootDir>/src\\xxx.tsxparserOptions.project I tried to fix it by following the steps in the error message, but it didn't work. Then I ...",
    "content": "The error message displayed in my terminal was as follows:\nI tried to fix it by following the steps in the error message, but it didn't work.\nThen I tried to understand why the xxx.tsx file had a problem while other files were fine.\nSurprisingly, I found two files in my 'src' folder: one called \"xxx.tsx\" and another called 'xxx.ts'.\nYes, you guessed it - the two files had the same name but different extensions.\nIn the end, I wish the terminal log could have given me a better hint to fix this kind of problem.",
    "tags": [
      "ESLINT",
      "REACT"
    ],
    "date": "2024-10-10",
    "readingTime": "2 min read",
    "url": "/blog/debugging-a-mysterious-eslint-error",
    "searchText": "Debugging a Mysterious ESLint Error The error message displayed in my terminal was as follows I tried to fix it by following the steps in the error message but it didn t work Then I tried to understand why the xxx tsx file had a problem while other files were fine Surprisingly I found two files in my src folder one called xxx tsx and another called xxx ts Yes you guessed it the two files had the same name but different extensions In the end I wish the terminal log could have given me a better hint to fix this kind of problem"
  },
  {
    "id": "design-pattern-simple-factory-pattern",
    "title": "Design Pattern - Simple Factory Pattern",
    "summary": "The design pattern is a general, reusable solution to a commonly occurring problem within a given context in software design. I have learned some design patterns in the past, but I don't think I have ...",
    "content": "The design pattern is a general, reusable solution to a commonly occurring problem within a given context in software design.\nI have learned some design patterns in the past, but I don't think I have a good understanding of them. So I want to write down what I have learned and my thoughts on them.\nIn most cases, I will use React and TypeScript in my projects, so the examples and explanations will be related to these two technologies.\nHere is an easy example of recommended product system. you can input the category of the product, and the system will recommend the products.\nnow, it contains three types of products: phone, tablet, and laptop. And all logic is in the  class. But if we want to add more products in the future, we need to modify the  class. and it violates the Open/Closed Principle.\nSo we can make some changes to the code.\nAll logic is also in the  class. But it defines three methods to recommend products. Now, the  class is more flexible and easier to maintain.\nIf we want t",
    "tags": [
      "DESIGN PATTERN",
      "SIMPLE FACTORY PATTERN"
    ],
    "date": "2024-10-13",
    "readingTime": "4 min read",
    "url": "/blog/design-pattern-simple-factory-pattern",
    "searchText": "Design Pattern Simple Factory Pattern The design pattern is a general reusable solution to a commonly occurring problem within a given context in software design I have learned some design patterns in the past but I don t think I have a good understanding of them So I want to write down what I have learned and my thoughts on them In most cases I will use React and TypeScript in my projects so the examples and explanations will be related to these two technologies Here is an easy example of recommended product system you can input the category of the product and the system will recommend the products now it contains three types of products phone tablet and laptop And all logic is in the class But if we want to add more products in the future we need to modify the class and it violates the Open Closed Principle So we can make some changes to the code All logic is also in the class But it defines three methods to recommend products Now the class is more flexible and easier to maintain If we want to add more products in the future we can just add more methods like and But it violates the Open Closed Principle And the class is still too long Single Responsibility Principle is also violated So we can seperate the responsibilities of the class Now the different types of products are separated into different classes If we want to add more products in the future we can just add more classes like and And the class is more concise and easier to understand But it violates the Single Responsibility Principle Let s try to use the factory pattern to solve this problem Finally we add a class to create the recommender instances Now the class is more flexible and easier to maintain And it follows the Open Closed Principle and Single Responsibility Principle"
  },
  {
    "id": "get-image-dom-base64-png-url",
    "title": "Get Img Dom Base64 Png Url",
    "summary": "One way to get base64 png url from a img dom",
    "content": "Please note that if the src attribute of your img tag points to a resource outside your website, you may encounter a CORS issue.",
    "tags": [
      "IMG",
      "WEB",
      "BASE64",
      "PNG"
    ],
    "date": "2024-07-20",
    "readingTime": "1 min read",
    "url": "/blog/get-image-dom-base64-png-url",
    "searchText": "Get Img Dom Base64 Png Url Please note that if the src attribute of your img tag points to a resource outside your website you may encounter a CORS issue"
  },
  {
    "id": "independent-module-url-processing-for-new-Worker",
    "title": "Independent Module Url Processing For New Worker()",
    "summary": "One way to get right url in new Worker()",
    "content": "Yesterday, I found a problem with  in my frontend page.\nWhen I upload a file to server, the browser tells me an error.\nHere is my code.\nI think it could work until the file upload module was split as a independent module(We call it UploadFileApp) from a big web application(We call it BigWebApp, it's based on Next and React). So I want to compare what's the difference between them.\nFirst, I try to hit some breakpoints, and use  to show me more information\nObviously,  return the file  and show it's path in it's file Location, and because of module split, it changed. But, to my surprise,  return completely different result.\n is my upload module server host and port\nIt seems that old result is a static file, and it's generated by Next in . And the new result is also a static file, But it's generated by Webpack in .\nThe key is that when you use ,  and , you should consider where will it be used.\nSo When I use  inside , its incoming parameter is totally wrong.\nThere is a less elegant solutio",
    "tags": [
      "New Worker()",
      "New URL()",
      "Module"
    ],
    "date": "2023-05-27",
    "readingTime": "5 min read",
    "url": "/blog/independent-module-url-processing-for-new-Worker",
    "searchText": "Independent Module Url Processing For New Worker Yesterday I found a problem with in my frontend page When I upload a file to server the browser tells me an error Here is my code I think it could work until the file upload module was split as a independent module We call it UploadFileApp from a big web application We call it BigWebApp it s based on Next and React So I want to compare what s the difference between them First I try to hit some breakpoints and use to show me more information Obviously return the file and show it s path in it s file Location and because of module split it changed But to my surprise return completely different result is my upload module server host and port It seems that old result is a static file and it s generated by Next in And the new result is also a static file But it s generated by Webpack in The key is that when you use and you should consider where will it be used So When I use inside its incoming parameter is totally wrong There is a less elegant solution for me just replace with asynchronously read and process the file Actually my script in is just to calculate MD5 So I change my code and calculate MD5 without After some tests It looks like it s okay but is there any way we can continue to use I ask chatGPT for help chatGPT tell me two ways to solve the problem Using a static location to store script like cdn Using Blob and URL createObjectURL In my project I don t a static location to store script So the only way is using Blob and URL createObjectURL First of all I can t import SparkMD5 from spark md5 directly in I need to download spark md5 js and store it in my local folder localThirdModule I don t known why the MDN say the first incoming parameter is just a string representing the URL of the script the worker will execute But you can even pass a function and use it s result as first incoming parameter Finally you can see there is a method to releases an existing object URL which was previously created by calling URL createObjectURL But in my application I can t find a fit place to use it Maybe one day it will give me a hammer blow o o"
  },
  {
    "id": "prepare-for-my-blog",
    "title": "Prepare For My Blog",
    "summary": "Two mistakes in my blog config",
    "content": "After I deploy my website, I find two mistakes in my blog config.\nI want to use giscus, but I find it can't work in my blog. I open an article, and scroll down, click the  button, and it shows:\nMy giscus's config is written in  file, then I write some code in \nand I find the  is , so I think the config is not loaded.I search it in Google, and the env config file should end with , so I rename  to , and it works.\nWhen I open the developer tools, I find there are some errors in the console.\nIt's an error about the , I search it in Google, and I find the solution is to change  in the  config in .\nThat's mean I trust the file in  domain, and I can use the  file.",
    "tags": [
      "Blog Config"
    ],
    "date": "2023-04-20",
    "readingTime": "2 min read",
    "url": "/blog/prepare-for-my-blog",
    "searchText": "Prepare For My Blog After I deploy my website I find two mistakes in my blog config I want to use giscus but I find it can t work in my blog I open an article and scroll down click the button and it shows My giscus s config is written in file then I write some code in and I find the is so I think the config is not loaded I search it in Google and the env config file should end with so I rename to and it works When I open the developer tools I find there are some errors in the console It s an error about the I search it in Google and I find the solution is to change in the config in That s mean I trust the file in domain and I can use the file"
  },
  {
    "id": "react-document-summary",
    "title": "React Document Summary",
    "summary": "react-hook use  with  to reduce unnecessary child-component re-render use  and wrap child components in  to share data between components without passing data by props. use  with  to improve user expe...",
    "content": "react-hook\nuse  with  to reduce unnecessary child-component re-render\nuse  and wrap child components in  to share data between components without passing data by props.\nuse  with  to improve user experience by update a part of UI.\nuse  to get data, Connecting to an external system.\nuse  to generate Id for aria-describe\nuse  to make the parent component to get the child commponent's ref without true dom, but only some methods that the child component want to expose.\nuse  to inject dynamic styles from CSS-in-JS libraries. It's happen before DOM mutations.\nuse  to measure layout before the browser repaints the screen\nuse  to cache a function result between re-renders.\ntry to separate a object dependencies to more single variable.\na example explain  and \nuse  to set initial state and change state by dispatch action.\nuse  to store data that won't change in screen, If you want to change , You should change it during  or in a event handler like .\nIf use map/EChart/VideoPlayer, just initial co",
    "tags": [
      "React",
      "Hook",
      "React Components"
    ],
    "date": "2023-05-08",
    "readingTime": "3 min read",
    "url": "/blog/react-document-summary",
    "searchText": "React Document Summary react hook use with to reduce unnecessary child component re render use and wrap child components in to share data between components without passing data by props use with to improve user experience by update a part of UI use to get data Connecting to an external system use to generate Id for aria describe use to make the parent component to get the child commponent s ref without true dom but only some methods that the child component want to expose use to inject dynamic styles from CSS in JS libraries It s happen before DOM mutations use to measure layout before the browser repaints the screen use to cache a function result between re renders try to separate a object dependencies to more single variable a example explain and use to set initial state and change state by dispatch action use to store data that won t change in screen If you want to change You should change it during or in a event handler like If use map EChart VideoPlayer just initial constructor once use if you want to expose the child component ref to the parent component use if you initial a state by passing a function which look like if you need to integrate with existing non React code such as use use update the state without blocking the UI Toggle components by changing tab UI will be blocked put the in function React Components can pass key in array loop phase mount update or nested update compare you will know whether memorization work enable trigger once more method warn you some deprecation methods If you use in a nested components maybe you don t want to show fallback content when some useful content already exist So use or and pass in callback function API use with and use to pass ref to custom component use in react router classnames use the function in it will not block UI drag drop api use place the component in what you want example use For example the browser onbeforeprint API allows you to change the page immediately before the print dialog opens This is useful for applying custom print styles that allow the document to display better for printing In the example below you use flushSync inside of the onbeforeprint callback to immediately flush the React state to the DOM Then by the time the print dialog opens isPrinting displays yes"
  },
  {
    "id": "start-mobx-with-react",
    "title": "Start Mobx With React",
    "summary": "Two hooks to start Mobx with React",
    "content": "Maybe two years ago, My friend Bryan suggest me to replace redux to mobx. I remember when I opened the document of mobx, I was confused by the document, and I didn't know how to start. So I gave up.\nLuckily, I find an easy-to-follow tutorial today, Introduction to MobX & React in 2020.\nSo, Let's start!\nFirst of all, you can create an react app by using create-react-app, then in order to support , you need to eject the app.\nand change the  to support .\nThen, you can install  and .\nHere comes the point!\nJust like redux, you need create a store to manage the state. In mobx, you can use  to create a store.It includes data, action and computed method.\nThen, you can wrap  in , then  can access the store.\nIn order to get store in , you can use  to get the store. If you want to make your component re-render when the store changes, you can use .\nSo, just two hooks ,  you need to know to start mobx with react. In real project, you may want to have multiple stores for different components.\nHave a",
    "tags": [
      "Mobx",
      "React",
      "State Management"
    ],
    "date": "2023-04-21",
    "readingTime": "3 min read",
    "url": "/blog/start-mobx-with-react",
    "searchText": "Start Mobx With React Maybe two years ago My friend Bryan suggest me to replace redux to mobx I remember when I opened the document of mobx I was confused by the document and I didn t know how to start So I gave up Luckily I find an easy to follow tutorial today Introduction to MobX React in 2020 So Let s start First of all you can create an react app by using create react app then in order to support you need to eject the app and change the to support Then you can install and Here comes the point Just like redux you need create a store to manage the state In mobx you can use to create a store It includes data action and computed method Then you can wrap in then can access the store In order to get store in you can use to get the store If you want to make your component re render when the store changes you can use So just two hooks you need to know to start mobx with react In real project you may want to have multiple stores for different components Have a try"
  },
  {
    "id": "webpack中的loader",
    "title": "webpack中的loader",
    "summary": "loader 是什么？ 是一个文件处理器 为什么需要 loader？ webpack本身只能处理 js 文件，而通过 loader 可以让 webpack 处理非 js 的文件（比如图片，css等），把它们变成可以识别和打包的模块。 它是如何工作的？ 1. 匹配文件：在配置中定义规则（如 test: /\\.css$/），指定哪些文件由 loader 处理。 2. ​转换内容​：loader 是函数...",
    "content": "loader 是什么？\n是一个文件处理器\n为什么需要 loader？\nwebpack本身只能处理 js 文件，而通过 loader 可以让 webpack 处理非 js 的文件（比如图片，css等），把它们变成可以识别和打包的模块。\n它是如何工作的？\n匹配文件：在配置中定义规则（如 test: /\\.css$/），指定哪些文件由 loader 处理。\n​转换内容​：loader 是函数，接收文件内容，返回处理结果（如将 CSS 代码转为 JavaScript 模块）。\n​链式调用​：多个 loader 可顺序执行（如先编译 SCSS 为 CSS，再嵌入页面）\n最佳实践​：\n​功能单一​：一个 loader 只做一件事（如less-loader 专处理 Less 语法）。\n​使用官方工具​：通过 this.getOptions()获取配置，保持 loader 无状态。\n​示例场景​：处理 CSS 时，常用 css-loader（解析 CSS 依赖）和 style-loader（将样式注入页面）",
    "tags": [
      "webpack"
    ],
    "date": "2025-10-29",
    "readingTime": "2 min read",
    "url": "/blog/webpack中的loader",
    "searchText": "webpack中的loader loader 是什么 是一个文件处理器 为什么需要 loader webpack本身只能处理 js 文件 而通过 loader 可以让 webpack 处理非 js 的文件 比如图片 css等 把它们变成可以识别和打包的模块 它是如何工作的 匹配文件 在配置中定义规则 如 test css 指定哪些文件由 loader 处理 转换内容 loader 是函数 接收文件内容 返回处理结果 如将 CSS 代码转为 JavaScript 模块 链式调用 多个 loader 可顺序执行 如先编译 SCSS 为 CSS 再嵌入页面 最佳实践 功能单一 一个 loader 只做一件事 如less loader 专处理 Less 语法 使用官方工具 通过 this getOptions 获取配置 保持 loader 无状态 示例场景 处理 CSS 时 常用 css loader 解析 CSS 依赖 和 style loader 将样式注入页面"
  },
  {
    "id": "webpack对比vite",
    "title": "webpack对比vite",
    "summary": "在公司真正的商业项目中，当前使用的都是 webpack,而我自己搞 demo 之类的，会更偏向于 vite 这种开箱即用的。那么这两个打包工具，究竟有哪些差异？我们在不同的场景下又应该如何抉择呢？ 一句话结论：如果没有企业级高复杂度打包定制需求，请直接选用 vite。 接下来我们再讨论几个细节： 它们的核心实现原理？webpack 是构建时打包（bundle-based），而 vite 是基于原生...",
    "content": "在公司真正的商业项目中，当前使用的都是 webpack,而我自己搞 demo 之类的，会更偏向于 vite 这种开箱即用的。那么这两个打包工具，究竟有哪些差异？我们在不同的场景下又应该如何抉择呢？\n一句话结论：如果没有企业级高复杂度打包定制需求，请直接选用 vite。\n接下来我们再讨论几个细节：\n它们的核心实现原理？webpack 是构建时打包（bundle-based），而 vite 是基于原生的 ES 模块。那么最直接的影响就是你发现 npm run dev 之后，webpack 还在那走进度条呢，vite 已经让你去打开网页了。甚至你修改了一丢丢代码，如果工程真的非常大的话，webpack 在控制台还得显示一会compiling，而 vite 又是秒处理。对于开发人员来说，最核心的差异在冷启动和热更新的速度上。当然vite快的代价也是有的，就是在开发的时候，首屏加载慢的要死，因为要动态编译。\n曾几何时，有一个岗位叫 webpack 配置工程师，虽有戏谑的成分在里面，但也真实展示了 webpack 配置的复杂性，如果你认真去读 webpack 的文档，咱都不说让你去懂实现原理，去看源码，你只把所有配置项都搞清楚，我觉得你在 webpack 配置领域，应该都是独孤求败了。我有无数次打开 webpack 官网，吭哧吭哧看了几章，觉得好像也没啥了不起的，但只要我不去反复修改相关配置，以及真的去看它的源码设计，那知识就像海鸥，飞过我的脑子，不留下任何痕迹。实际上呢，我们常用的 webpack 配置，其实也没多少项。你最常改动的地方，很可能就是 proxy 的部分了，连不同的后端环境啥的，都靠这个（如果你们没有一个自动 nginx 后端转发服务的话）。还有一个 sourceMap 相关的配置，生产环境不能把源码暴露出来（最近 apple 就把源码直接上生产环境了，所以这地方一定要注意，当然正常生产环境打包肯定是固定流水线处理，靠人工的话，一定会爆炸的，只是早晚的问题），在开发环境，肯定是越详细越好了。此外，你可能关注到 webpack 有一堆 loader 和 plugin。那它们又是干啥的呢🤔？一句话结论：webpack本身只处理js，有了loader就可以处理其他格式的文件（本质上是一个纯函数），而有了plugin就可以处理loader处理不了的东西。比较常用的lo",
    "tags": [
      "webpack",
      "vite"
    ],
    "date": "2025-11-06",
    "readingTime": "6 min read",
    "url": "/blog/webpack对比vite",
    "searchText": "webpack对比vite 在公司真正的商业项目中 当前使用的都是 webpack 而我自己搞 demo 之类的 会更偏向于 vite 这种开箱即用的 那么这两个打包工具 究竟有哪些差异 我们在不同的场景下又应该如何抉择呢 一句话结论 如果没有企业级高复杂度打包定制需求 请直接选用 vite 接下来我们再讨论几个细节 它们的核心实现原理 webpack 是构建时打包 bundle based 而 vite 是基于原生的 ES 模块 那么最直接的影响就是你发现 npm run dev 之后 webpack 还在那走进度条呢 vite 已经让你去打开网页了 甚至你修改了一丢丢代码 如果工程真的非常大的话 webpack 在控制台还得显示一会compiling 而 vite 又是秒处理 对于开发人员来说 最核心的差异在冷启动和热更新的速度上 当然vite快的代价也是有的 就是在开发的时候 首屏加载慢的要死 因为要动态编译 曾几何时 有一个岗位叫 webpack 配置工程师 虽有戏谑的成分在里面 但也真实展示了 webpack 配置的复杂性 如果你认真去读 webpack 的文档 咱都不说让你去懂实现原理 去看源码 你只把所有配置项都搞清楚 我觉得你在 webpack 配置领域 应该都是独孤求败了 我有无数次打开 webpack 官网 吭哧吭哧看了几章 觉得好像也没啥了不起的 但只要我不去反复修改相关配置 以及真的去看它的源码设计 那知识就像海鸥 飞过我的脑子 不留下任何痕迹 实际上呢 我们常用的 webpack 配置 其实也没多少项 你最常改动的地方 很可能就是 proxy 的部分了 连不同的后端环境啥的 都靠这个 如果你们没有一个自动 nginx 后端转发服务的话 还有一个 sourceMap 相关的配置 生产环境不能把源码暴露出来 最近 apple 就把源码直接上生产环境了 所以这地方一定要注意 当然正常生产环境打包肯定是固定流水线处理 靠人工的话 一定会爆炸的 只是早晚的问题 在开发环境 肯定是越详细越好了 此外 你可能关注到 webpack 有一堆 loader 和 plugin 那它们又是干啥的呢 一句话结论 webpack本身只处理js 有了loader就可以处理其他格式的文件 本质上是一个纯函数 而有了plugin就可以处理loader处理不了的东西 比较常用的loader 有处理css的 有处理图片的 处理ts的 而比较常用的plugin就有htmlxxx 把打包好的css js 注入html cleanyyy 清理打包产物 一般用在打包之前 我觉得对于日常开发来说 了解到这应该可以了 具体webpack 怎么去配置 建议还是去网上找一个最佳实践 先用起来 再针对自己的项目特点做一些定制改造就可以了 说完了webpack的坑爹 vite就显得小巧可爱了 开箱即用 不用关心那么多东西 又不是不能用 你如果真有一个需求 只能通过webpack的插件实现 而vite没有的话 那建议你直接找到那个插件的源码 让ai翻译一遍就完事了 为了在打包生成生产环境的包 webpack 这边用的是自身的打包器 经受住了历史的考验 而vite这边则是基于rollup 一般情况下打包体积会小一点 在底层语言上 webpack是基于nodejs的 所以你可以看到很多webpack的模块 需要你require 进来 而vite则是用了esbuild 用go写的 在对于文件的处理上 webpack像是把所有东西 都通过loader变成它能处理的模块 而vite这边则通过浏览器原生esm按需加载 最后总结 人生苦短 我选vite 古董项目 啥也别改 项目和人 有一个能跑就行了"
  },
  {
    "id": "事件循环",
    "title": "事件循环",
    "summary": "事件循环是浏览器协调任务执行的机制，因为浏览器是单线程的，为了避免耗时任务卡住主线程，所以它把任务分成了 4 类 1. 同步任务：需要立即执行的任务，会阻塞后续代码，直到其完成，可能会阻塞主线程，比如 console.log() 2. 异步任务：不需要立即执行的任务，执行完成后需要通知主线程的，异步任务又分为宏任务和微任务。 3. 宏任务：优先级更低的异步任务，不会阻塞主线程。包括整体  脚本的加...",
    "content": "事件循环是浏览器协调任务执行的机制，因为浏览器是单线程的，为了避免耗时任务卡住主线程，所以它把任务分成了 4 类\n同步任务：需要立即执行的任务，会阻塞后续代码，直到其完成，可能会阻塞主线程，比如 console.log()\n异步任务：不需要立即执行的任务，执行完成后需要通知主线程的，异步任务又分为宏任务和微任务。\n宏任务：优先级更低的异步任务，不会阻塞主线程。包括整体  脚本的加载，setTimeout/setInterval，requestAnimationFrame，I/O 操作，DOM 事件\n微任务：优先级更高的异步任务，不会阻塞主线程，但长时间运行会延迟渲染。包括 promise.then/catch/finally，async/await，MutationObserver，在当前宏任务结束后，立即执行，并清空微任务队列。\n执行顺序：\n整个脚本本身首先作为一个宏任务执行。在这个宏任务内部，先执行所有同步代码。执行完毕后，开始清空此轮产生的微任务队列。清空后，浏览器判断是否需要重绘重排（可能进行UI渲染）。然后才开始取下一個宏任务（如setTimeout回调），并重复此过程（执行该宏任务内的同步代码->清空微任务->渲染...），形成事件循环。\n应用在什么场景下？\nFetch 请求（I/O 操作，宏任务）成功返回的是一个 promise.then 或者 await（微任务），确保数据拿到后可以立即处理\n使用 requestAnimationFrame 优化动画（宏任务）\n最佳实践是什么？\n由于浏览器的单线程特性，当需要执行复杂耗时运算时，通过 setTimeout或 requestAnimationFrame（一种与渲染相关的宏任务）分片执行，也避免了线程阻塞。也可以放入 web worker 中独立处理。\n除非业务必须，默认页面所有接口并发处理，使用 Promise.all，通过微任务集中处理数据，保证数据拿到后可以立即处理\n现代框架的异步更新机制，依赖于微任务，将多个数据变更收集起来，在同一个事件循环的微任务阶段进行批量DOM更新，避免不必要的重复渲染，提升性能（类似于在 react 中多次 setState，react 不会在每次 setState 后立即刷新组件，更新 DOM，而是合并后，再更新一次 DOM）\n由于在事件循环中，只有在微任务队列清空后，",
    "tags": [
      "Promise",
      "setTimeout",
      "Event loop"
    ],
    "date": "2025-10-21",
    "readingTime": "6 min read",
    "url": "/blog/事件循环",
    "searchText": "事件循环 事件循环是浏览器协调任务执行的机制 因为浏览器是单线程的 为了避免耗时任务卡住主线程 所以它把任务分成了 4 类 同步任务 需要立即执行的任务 会阻塞后续代码 直到其完成 可能会阻塞主线程 比如 console log 异步任务 不需要立即执行的任务 执行完成后需要通知主线程的 异步任务又分为宏任务和微任务 宏任务 优先级更低的异步任务 不会阻塞主线程 包括整体 脚本的加载 setTimeout setInterval requestAnimationFrame I O 操作 DOM 事件 微任务 优先级更高的异步任务 不会阻塞主线程 但长时间运行会延迟渲染 包括 promise then catch finally async await MutationObserver 在当前宏任务结束后 立即执行 并清空微任务队列 执行顺序 整个脚本本身首先作为一个宏任务执行 在这个宏任务内部 先执行所有同步代码 执行完毕后 开始清空此轮产生的微任务队列 清空后 浏览器判断是否需要重绘重排 可能进行UI渲染 然后才开始取下一個宏任务 如setTimeout回调 并重复此过程 执行该宏任务内的同步代码 清空微任务 渲染 形成事件循环 应用在什么场景下 Fetch 请求 I O 操作 宏任务 成功返回的是一个 promise then 或者 await 微任务 确保数据拿到后可以立即处理 使用 requestAnimationFrame 优化动画 宏任务 最佳实践是什么 由于浏览器的单线程特性 当需要执行复杂耗时运算时 通过 setTimeout或 requestAnimationFrame 一种与渲染相关的宏任务 分片执行 也避免了线程阻塞 也可以放入 web worker 中独立处理 除非业务必须 默认页面所有接口并发处理 使用 Promise all 通过微任务集中处理数据 保证数据拿到后可以立即处理 现代框架的异步更新机制 依赖于微任务 将多个数据变更收集起来 在同一个事件循环的微任务阶段进行批量DOM更新 避免不必要的重复渲染 提升性能 类似于在 react 中多次 setState react 不会在每次 setState 后立即刷新组件 更新 DOM 而是合并后 再更新一次 DOM 由于在事件循环中 只有在微任务队列清空后 才会执行下一个宏任务 如果在微任务中递归添加微任务 就会使得宏任务无限延期 页面无法渲染和响应事件 需要避免这种操作 拓展 一个比较复杂的示例"
  },
  {
    "id": "关于前端项目的思考",
    "title": "关于前端项目的思考",
    "summary": "对于某一类特定的需求，过于原子化的组件化开发方式并不能够彻底地解决开发效率问题，从抽象的业务需求中能够具象出较为通用的可插拔可组合的技术方案才是解决实际问题的终极答案。 下面给出几个常见场景 页面布局方案 1. 布局与路由的结合。如何实现不同路由不同布局？将布局组件作为传入不同的页面组件上 2. 页眉：应用层页眉（数据传递给外面，不接收外层传入的数据），页面层页眉（数据从外层传入） 3. 在企业管...",
    "content": "对于某一类特定的需求，过于原子化的组件化开发方式并不能够彻底地解决开发效率问题，从抽象的业务需求中能够具象出较为通用的可插拔可组合的技术方案才是解决实际问题的终极答案。\n下面给出几个常见场景\n页面布局方案\n布局与路由的结合。如何实现不同路由不同布局？将布局组件作为传入不同的页面组件上\n页眉：应用层页眉（数据传递给外面，不接收外层传入的数据），页面层页眉（数据从外层传入）\n在企业管理系统中，作为一个应用级别的解决方案，能使用配置项解决的问题我们都应该尽量避免让使用者编写代码\nUI 与数据在架构时应当是的，redux 作为二者之间的粘合剂，一旦二者通过 redux 被连接到了一起，那么这个组件也就不再了，变为了只隶属于当前项目的一个业务组件且不再具备通用性\n：应用层、布局层、页面层、组件层\n权限管理机制\n权限的设计：基于角色的访问控制（创建者/管理员/普通用户/游客）+ 访问列表控制（控制某个模块是否可见）\n路由层面容器的管理：\n区分需鉴权页面路由和无需鉴权页面路由（比如登录页面）\n在需要登录鉴权的路由中通过(在 umi 中直接可用的)，进行鉴权判断，当无权限的时候，跳转到登录页或提示无权限访问\n对于无法匹配的路径，也要在页面提示用户404当前页面路径不存在\n通过配置的方式，让路由的修改和新增都更容易处理了\n注意权限管理部分的逻辑是的\n文档目录树\n每一层级都有一个唯一 id，且深层元素也要（比如 path 属性： parentId/childId），从而实现菜单栏多级高亮。针对文档目录树，给节点增加带有上级节点标识的属性，对于后续在树上做增删改查操作有着极大的便利\n利用 pathname 及 treeData 计算出当前的 selectedKeys/selectedNode，可以通过  优化这个过程\n区分 props 和 state：props 从外部获得（组件内部无法计算出来），state 在组件内部（不应该被外部数据所改变）\n消息通知的设计\n应用层处理全局消息通知：登录完成后立即获取一次，后续使用 unread 接口轮询（此处 unread 接口还可以承担用户超时后，发送请求，触发超时等出的逻辑，但这么搞的话，也相当于违反了单一职责原则，需在具体场景具体分析）\n数据驱动视图：当有未读消息的时候，自动展示\n归根结底其降低内部复杂度的方式就是分层。通过不断地分层将整体复",
    "tags": [],
    "date": "2025-10-25",
    "readingTime": "6 min read",
    "url": "/blog/关于前端项目的思考",
    "searchText": "关于前端项目的思考 对于某一类特定的需求 过于原子化的组件化开发方式并不能够彻底地解决开发效率问题 从抽象的业务需求中能够具象出较为通用的可插拔可组合的技术方案才是解决实际问题的终极答案 下面给出几个常见场景 页面布局方案 布局与路由的结合 如何实现不同路由不同布局 将布局组件作为传入不同的页面组件上 页眉 应用层页眉 数据传递给外面 不接收外层传入的数据 页面层页眉 数据从外层传入 在企业管理系统中 作为一个应用级别的解决方案 能使用配置项解决的问题我们都应该尽量避免让使用者编写代码 UI 与数据在架构时应当是的 redux 作为二者之间的粘合剂 一旦二者通过 redux 被连接到了一起 那么这个组件也就不再了 变为了只隶属于当前项目的一个业务组件且不再具备通用性 应用层 布局层 页面层 组件层 权限管理机制 权限的设计 基于角色的访问控制 创建者 管理员 普通用户 游客 访问列表控制 控制某个模块是否可见 路由层面容器的管理 区分需鉴权页面路由和无需鉴权页面路由 比如登录页面 在需要登录鉴权的路由中通过 在 umi 中直接可用的 进行鉴权判断 当无权限的时候 跳转到登录页或提示无权限访问 对于无法匹配的路径 也要在页面提示用户404当前页面路径不存在 通过配置的方式 让路由的修改和新增都更容易处理了 注意权限管理部分的逻辑是的 文档目录树 每一层级都有一个唯一 id 且深层元素也要 比如 path 属性 parentId childId 从而实现菜单栏多级高亮 针对文档目录树 给节点增加带有上级节点标识的属性 对于后续在树上做增删改查操作有着极大的便利 利用 pathname 及 treeData 计算出当前的 selectedKeys selectedNode 可以通过 优化这个过程 区分 props 和 state props 从外部获得 组件内部无法计算出来 state 在组件内部 不应该被外部数据所改变 消息通知的设计 应用层处理全局消息通知 登录完成后立即获取一次 后续使用 unread 接口轮询 此处 unread 接口还可以承担用户超时后 发送请求 触发超时等出的逻辑 但这么搞的话 也相当于违反了单一职责原则 需在具体场景具体分析 数据驱动视图 当有未读消息的时候 自动展示 归根结底其降低内部复杂度的方式就是分层 通过不断地分层将整体复杂度合理地分散在每一个模块中并将其封装起来 从而达到极大地降低拼接不同模块时复杂度的目的 对于任意一个模块来说 衡量其优秀程度的维度有三点 能否和当前系统配合起来完成具体任务 这个模块是否和其上下游的模块强耦合 即其他模块是否需要为了适应它而做出特殊的调整 好的模块是为其他模块赋能的 即赋予其他模块更多的能力而不需要其他模块做出任何的妥协或牺牲 这个模块是否能够无缝地迁移到其他的系统并完成同样的工作 这就涉及软件工程中经常讲的可复用性 即一个模块自身的封装是否足够优秀以至于并不会因为所处系统的不同而需要做特殊的调整"
  },
  {
    "id": "前端代码可维护性提升",
    "title": "前端代码可维护性提升",
    "summary": "1. 在需求设计阶段打好地基，明确模块的单一职责，避免功能混杂，预判扩展性，安全性和对性能造成的影响 2. 在业务迭代中，定期重构冗余代码，进一步抽象逻辑，将页面拆分为更独立的组件。注意在重构过程中，通过自动化用例测试避免引入新的问题 3. 强化错误定位能力，通过归档生产环境 SourceMap ，提高定位线上问题的效率 4. 通过性能检测平台监测关键指标（页面响应速度，操作响应时间），及时发现错...",
    "content": "在需求设计阶段打好地基，明确模块的单一职责，避免功能混杂，预判扩展性，安全性和对性能造成的影响\n在业务迭代中，定期重构冗余代码，进一步抽象逻辑，将页面拆分为更独立的组件。注意在重构过程中，通过自动化用例测试避免引入新的问题\n强化错误定位能力，通过归档生产环境 SourceMap ，提高定位线上问题的效率\n通过性能检测平台监测关键指标（页面响应速度，操作响应时间），及时发现错误并做针对性优化，形成监测-分析-优化的闭环。\n团队需遵循一致的代码风格（ESLint/Prettier/Git 钩子，流水线检测），针对重点改动需有详尽的文档记录（聚焦“为什么这样设计”而非“代码做了什么）\n封装通用工具函数（如日期格式化、请求封装），并通过模块化设计减少代码重复\n模块化侧重逻辑拆分（如工具函数库），组件化侧重UI拆分（如按钮组件）",
    "tags": [],
    "date": "2025-10-22",
    "readingTime": "2 min read",
    "url": "/blog/前端代码可维护性提升",
    "searchText": "前端代码可维护性提升 在需求设计阶段打好地基 明确模块的单一职责 避免功能混杂 预判扩展性 安全性和对性能造成的影响 在业务迭代中 定期重构冗余代码 进一步抽象逻辑 将页面拆分为更独立的组件 注意在重构过程中 通过自动化用例测试避免引入新的问题 强化错误定位能力 通过归档生产环境 SourceMap 提高定位线上问题的效率 通过性能检测平台监测关键指标 页面响应速度 操作响应时间 及时发现错误并做针对性优化 形成监测 分析 优化的闭环 团队需遵循一致的代码风格 ESLint Prettier Git 钩子 流水线检测 针对重点改动需有详尽的文档记录 聚焦 为什么这样设计 而非 代码做了什么 封装通用工具函数 如日期格式化 请求封装 并通过模块化设计减少代码重复 模块化侧重逻辑拆分 如工具函数库 组件化侧重UI拆分 如按钮组件"
  },
  {
    "id": "前端性能优化",
    "title": "前端性能优化",
    "summary": "前端性能优化指的是，通过各种技术手段，提高网页的加载速度，渲染速度，交互响应速度，减少资源占用，提高用户体验。 按照测量在先，优化在后的原则，我将从以下几个方面进行分析： 1. 性能检测 2. 网络请求优化 3. 资源加载优化 4. 代码与架构优化 5. 渲染性能优化 6. 感知体验优化 性能检测 1. 确立性能指标与目标：关注核心 Web 指标（Core Web Vitals）： - LCP（最...",
    "content": "前端性能优化指的是，通过各种技术手段，提高网页的加载速度，渲染速度，交互响应速度，减少资源占用，提高用户体验。\n按照测量在先，优化在后的原则，我将从以下几个方面进行分析：\n性能检测\n网络请求优化\n资源加载优化\n代码与架构优化\n渲染性能优化\n感知体验优化\n性能检测\n确立性能指标与目标：关注核心 Web 指标（Core Web Vitals）：\nLCP（最大内容绘制）​​：衡量加载速度，建议小于2.5秒。\nFID（首次输入延迟）​​：衡量交互性，建议小于100毫秒。\nCLS（累积布局偏移）​​：衡量视觉稳定性，建议小于0.1。\n性能监控流程化：\n实验室监控​：使用 Lighthouse、WebPageTest 等在开发阶段模拟测试。\n真实用户监控（RUM）​​：在生产环境通过 Performance API 收集真实用户数据，分析性能瓶颈。\n性能优化迭代​：性能优化是持续过程。定期（如每季度）通过监控数据复盘，针对退化或新瓶颈制定优化方案。\n网络请求优化\n合并重复请求，减少请求数量\n在 SaaS 系统中，经常有系统配置参数和用户配置参数。可以把分散在各个组件的配置参数查询归一化处理，在用户登录后统一请求，并存入 localStorage 中进行缓存（后续使用时直接读取，避免重复查询，注意涉及鉴权类信息不可存入，有安全隐患）\n针对大量小图标，可以考虑合成一张图，使用时通过 CSS控制显示不同的部分。但在 HTTP2多路复用的环境下，需权衡合并的收益和缓存颗粒度的影响\n服务端开启 GZIP 压缩\n   开启压缩后，可大幅减少请求包的大小，节省带宽，减少服务器端压力\n静态资源使用 CDN 加速\n   开启 CDN 加速后，用户可以就近访问\n使用 HTTP2，以及配置相应的 http 缓存，避免重复下载\n   升级到 HTTP2，可利用其二进制分帧和多路复用特性，极大提高请求的并发数量。\n   针对品牌图标，活动 banner 等资源，通过打包时将文件名称带上 hash 值后，可以设置强缓存（Cache-Control： max-age 设置一年）\n   针对容易变化的资源，可以设置 Etag，走协商缓存\n   http1.1 时代，为了突破浏览器并发请求数量，会把静态资源放到不同的域名下。升级到 HTTP2 之后，则要避免此操作，避免多余的DNS 查询和 TCP 连接开销\n预",
    "tags": [],
    "date": "2025-10-22",
    "readingTime": "11 min read",
    "url": "/blog/前端性能优化",
    "searchText": "前端性能优化 前端性能优化指的是 通过各种技术手段 提高网页的加载速度 渲染速度 交互响应速度 减少资源占用 提高用户体验 按照测量在先 优化在后的原则 我将从以下几个方面进行分析 性能检测 网络请求优化 资源加载优化 代码与架构优化 渲染性能优化 感知体验优化 性能检测 确立性能指标与目标 关注核心 Web 指标 Core Web Vitals LCP 最大内容绘制 衡量加载速度 建议小于2 5秒 FID 首次输入延迟 衡量交互性 建议小于100毫秒 CLS 累积布局偏移 衡量视觉稳定性 建议小于0 1 性能监控流程化 实验室监控 使用 Lighthouse WebPageTest 等在开发阶段模拟测试 真实用户监控 RUM 在生产环境通过 Performance API 收集真实用户数据 分析性能瓶颈 性能优化迭代 性能优化是持续过程 定期 如每季度 通过监控数据复盘 针对退化或新瓶颈制定优化方案 网络请求优化 合并重复请求 减少请求数量 在 SaaS 系统中 经常有系统配置参数和用户配置参数 可以把分散在各个组件的配置参数查询归一化处理 在用户登录后统一请求 并存入 localStorage 中进行缓存 后续使用时直接读取 避免重复查询 注意涉及鉴权类信息不可存入 有安全隐患 针对大量小图标 可以考虑合成一张图 使用时通过 CSS控制显示不同的部分 但在 HTTP2多路复用的环境下 需权衡合并的收益和缓存颗粒度的影响 服务端开启 GZIP 压缩 开启压缩后 可大幅减少请求包的大小 节省带宽 减少服务器端压力 静态资源使用 CDN 加速 开启 CDN 加速后 用户可以就近访问 使用 HTTP2 以及配置相应的 http 缓存 避免重复下载 升级到 HTTP2 可利用其二进制分帧和多路复用特性 极大提高请求的并发数量 针对品牌图标 活动 banner 等资源 通过打包时将文件名称带上 hash 值后 可以设置强缓存 Cache Control max age 设置一年 针对容易变化的资源 可以设置 Etag 走协商缓存 http1 1 时代 为了突破浏览器并发请求数量 会把静态资源放到不同的域名下 升级到 HTTP2 之后 则要避免此操作 避免多余的DNS 查询和 TCP 连接开销 预连接与DNS预解析 使用 dns prefetch和 preconnect资源提示 dns prefetch提前解析第三方资源的域名 preconnect则提前建立与服务器的连接 包括DNS查询 TCP握手 TLS协商 对关键第三方资源特别有用 资源加载优化 静态资源压缩 在生产环境下 通过 uglifyJsPlugin 等插件压缩 引入三方库时 注意使用其生产版本 字体 图片 优先使用高压缩 高质量的格式 并做优雅降级 字体 woff2 woff ttf 使用 font display swap 此CSS属性使文字在自定义字体加载完成前先显示系统字体 加载后再切换 有效避免因字体阻塞渲染导致的文字不可见 对首屏渲染至关重要的字体 可使用 提前加载 图片 avif webp jpeg png 注意svg类图片也要压缩 图片还可以通过使用 元素和 srcset属性 根据设备屏幕大小 像素密度等因素提供最合适的图片尺寸 按需加载 Tree Shaking 有了 ESM 的 import export 后 Webpack 可以在编译阶段分析依赖关系 从而进行 tree shaking 移除未使用的代码 针对大型组件 可以考虑做 Code Split 然后做懒加载 代码与架构优化 轻量库替换 比如用 day js 替换 moment js 去除不必要的依赖 插件 保持依赖库的更新 将已废弃的依赖 webpack 插件及时移除 并保持依赖库的更新 新版本的依赖通常会解决安全问题 拥有更好的性能 但也要注意兼容问题 JavaScript Css 代码层面的优化 避免在循环中操作 DOM 可以考虑使用虚拟 DOM 先处理完成后 找出需要在真实 DOM 上操作的最小集 或者使用 DocumentFragment 在内存中构建好 DOM 后 一次性插入到真实 DOM 中 仅触发一次重绘重排 可以将耗时较长的任务放入宏任务中处理 setTimeout requestAnimationFrame 涉及大计算量的部分 可以放入 web worker 中处理 使用浏览器缓存 localStorage SessionStorage Cookie IndexDB React 代码层面可以使用 useMemo useCallback 可以使用 ES6 的单例模式 在内存中实现数据的暂存和消费 注意 localStorage 是同步操作 应避免存储过大数据 频繁写入读取也会阻塞主线程 注意 组件 定时器 事件监听 的正确销毁 避免内存泄露 如非业务需要 默认使用 Promise all 并发接口请求 DOM 查询优化 尽量使用准确的元素查询器 默认是从右向左解析的 减少嵌套 慎用 querySelectorAll 查询大批量 DOM 使用 Vite 等新兴构建工具利用 ES Module 和原生技术 在启动速度和热更新上有显著优势 能极大提升开发体验和构建效率 渲染性能优化 懒加载 比如目录树的多层结构 ifame 等较重资源 也可以使用 loading lazy 处理 虚拟列表 只渲染可视窗口部分的 DOM 比如目录树的数量过多 列表页面的数量过多 优化渲染逻辑 避免多余的重绘重排 1 如果需要修改 DOM 样式 可以一次性修改 className 而不要每次修改一个属性 2 避免在修改 DOM 样式后 立即读取 DOM 涉及位置 布局的属性 比如 getComputedStyle 会导致强制同步 3 开启 GPU 加速 利用 transform translate opacity 等属性 触发合成层更新 4 对于复杂的动画 DOM 可以添加 will change 告知浏览器将会变化 5 如果一个 DOM 需要频繁修改 可以先设置 display none 待修改全部完成后 再改为 block 减少重绘重排 6 针对复杂的动画 DOM 可以通过设置 position fixed absolute 让它脱离正常文档流 避免影响其他部分 表格渲染优化 在表格中 单元格的高亮可以通过 css 实现 不要用 JavaScript 实现 可考虑数据分页 区分表格列的渲染优先级 优先展示数据列 然后再展示操作列 当鼠标移入单元格后 再加载 tooltip popConfirm 组件 利用 shouldCellUpdate 等方法 确保只有当单元格数据变化的时候 才触发刷新 注意如果数据的格式化计算较复杂时 也可以考虑将计算放在后端处理 超大流量页面优化 比如针对发布会当天的活动页面 可以采用静态页面直接展示 不启用编辑器的协同服务 只关注核心功能可用 感知体验优化 Loading动画 全局 图片 此处需要注意占位图的宽高要设置明确 避免页面闪烁 进度条展示当前任务处理进度 始终有兜底的错误提示信息 避免页面白屏"
  },
  {
    "id": "前端路由",
    "title": "前端路由",
    "summary": "前端路由是什么？ 前端路由能让浏览器不重新加载整个页面的条件下，通过改变 url 展示不同的组件，从而实现页面跳转的全前端（JavaScript）控制，是 SPA 的基础 为什么要有前端路由？ 1. 传统后端路由，在跳转后会先白屏，等接口重新返回 html 后，才能正常展示，前端路由可以实现\"无缝切换\" 2. 降低了服务端压力，无需每个页面都重新请求页面资源(CSS/JS) 3. 支持复杂应用交互...",
    "content": "前端路由是什么？\n前端路由能让浏览器不重新加载整个页面的条件下，通过改变 url 展示不同的组件，从而实现页面跳转的全前端（JavaScript）控制，是 SPA 的基础\n为什么要有前端路由？\n传统后端路由，在跳转后会先白屏，等接口重新返回 html 后，才能正常展示，前端路由可以实现\"无缝切换\"\n降低了服务端压力，无需每个页面都重新请求页面资源(CSS/JS)\n支持复杂应用交互，比如音乐播放器，在路由跳转后，还要保留当前的状态（比如音乐播放中）\n怎么实现？\nHash 路由，在 url 上可以看到 # ，依赖于 hashchange 事件的监听和触发。适合静态部署或兼容旧浏览器的项目\nHistory 路由，依赖于 popstate 事件的监听（仅浏览器前进/后退触发），以及 history.pushState() 方法更新 url（注意不会触发 popstate，需手动拦截标签点击，并更新UI） ，需要服务端配置支持(浏览器直接访问/home等路径会向服务器发送请求，若未配置统一回退根页面，则返回404错误。Nginx 服务端需将所有路由指向入口HTML文件)，URL更简洁，适合现代浏览器\"\n最佳实践？\n强制页面刷新的时候，会重置页面状态（如表单输入），但URL保留；前端路由库需通过sessionStorage或重新匹配路由恢复组件状态，而浏览器历史栈的URL记录确实存在\n路由的命名必须清晰明了\n结合鉴权使用时，严格区分需鉴权路由（个人文档页）和非鉴权路由（比如登录页，活动查看页）\n状态保留​：避免用window.location.reload()强制刷新，可使用路由库的“导航守卫”在跳转前保存数据\n错误处理：为无效URL设置兜底页面（如404页），提升用户体验\n懒加载优化：通过Webpack等工具将不同页面代码打包为独立文件，访问时再加载，减少初始负载量，提升首屏速度（如Vue中的() => import('./views/Home.vue')）",
    "tags": [
      "JavaScript",
      "Router"
    ],
    "date": "2025-10-27",
    "readingTime": "3 min read",
    "url": "/blog/前端路由",
    "searchText": "前端路由 前端路由是什么 前端路由能让浏览器不重新加载整个页面的条件下 通过改变 url 展示不同的组件 从而实现页面跳转的全前端 JavaScript 控制 是 SPA 的基础 为什么要有前端路由 传统后端路由 在跳转后会先白屏 等接口重新返回 html 后 才能正常展示 前端路由可以实现 无缝切换 降低了服务端压力 无需每个页面都重新请求页面资源 CSS JS 支持复杂应用交互 比如音乐播放器 在路由跳转后 还要保留当前的状态 比如音乐播放中 怎么实现 Hash 路由 在 url 上可以看到 依赖于 hashchange 事件的监听和触发 适合静态部署或兼容旧浏览器的项目 History 路由 依赖于 popstate 事件的监听 仅浏览器前进 后退触发 以及 history pushState 方法更新 url 注意不会触发 popstate 需手动拦截标签点击 并更新UI 需要服务端配置支持 浏览器直接访问 home等路径会向服务器发送请求 若未配置统一回退根页面 则返回404错误 Nginx 服务端需将所有路由指向入口HTML文件 URL更简洁 适合现代浏览器 最佳实践 强制页面刷新的时候 会重置页面状态 如表单输入 但URL保留 前端路由库需通过sessionStorage或重新匹配路由恢复组件状态 而浏览器历史栈的URL记录确实存在 路由的命名必须清晰明了 结合鉴权使用时 严格区分需鉴权路由 个人文档页 和非鉴权路由 比如登录页 活动查看页 状态保留 避免用window location reload 强制刷新 可使用路由库的 导航守卫 在跳转前保存数据 错误处理 为无效URL设置兜底页面 如404页 提升用户体验 懒加载优化 通过Webpack等工具将不同页面代码打包为独立文件 访问时再加载 减少初始负载量 提升首屏速度 如Vue中的 import views Home vue"
  },
  {
    "id": "区分type和interface",
    "title": "区分 type 和 interface",
    "summary": "typescript 就是在 JavaScript 的基础上，增加了类型系统，让代码在编写的时候，就可以发现错误。通过丰富的配置项，使得类型检查的严格程度可以自定义。 type 是类型别名，通过&实现交叉类型，不支持声明合并，不可被类实现 interface 是接口，使用 extends 继承，支持声明合并，可被类实现 解决什么问题？ 将弱类型的 JavaScript，转向\"强类型\"。更强的约束提...",
    "content": "typescript 就是在 JavaScript 的基础上，增加了类型系统，让代码在编写的时候，就可以发现错误。通过丰富的配置项，使得类型检查的严格程度可以自定义。\ntype 是类型别名，通过&实现交叉类型，不支持声明合并，不可被类实现\ninterface 是接口，使用 extends 继承，支持声明合并，可被类实现\n解决什么问题？\n将弱类型的 JavaScript，转向\"强类型\"。更强的约束提升了代码的可读性，并减少了低级错误的出现（比如去判断数字和字符串是否相等，而不是先统一类型再判断）\n如何使用以及最佳实践？\n针对对象类型，默认使用 interface 定义（如API返回的数据结构、React组件的Props），仅在 interface 能力不足的时候，使用 type 定义\ntype 是一个万能类型定义，涉及复杂类型运算（条件类型，联合类型）的使用 type。\n当类型定义一旦确定就不能修改的时候，用 type\ninterface的继承在属性类型冲突时会直接报错，而type的&交叉可能产生隐性的never类型。",
    "tags": [
      "TypeScript"
    ],
    "date": "2025-10-22",
    "readingTime": "2 min read",
    "url": "/blog/区分type和interface",
    "searchText": "区分 type 和 interface typescript 就是在 JavaScript 的基础上 增加了类型系统 让代码在编写的时候 就可以发现错误 通过丰富的配置项 使得类型检查的严格程度可以自定义 type 是类型别名 通过 实现交叉类型 不支持声明合并 不可被类实现 interface 是接口 使用 extends 继承 支持声明合并 可被类实现 解决什么问题 将弱类型的 JavaScript 转向 强类型 更强的约束提升了代码的可读性 并减少了低级错误的出现 比如去判断数字和字符串是否相等 而不是先统一类型再判断 如何使用以及最佳实践 针对对象类型 默认使用 interface 定义 如API返回的数据结构 React组件的Props 仅在 interface 能力不足的时候 使用 type 定义 type 是一个万能类型定义 涉及复杂类型运算 条件类型 联合类型 的使用 type 当类型定义一旦确定就不能修改的时候 用 type interface的继承在属性类型冲突时会直接报错 而type的 交叉可能产生隐性的never类型"
  },
  {
    "id": "异步编程",
    "title": "异步编程",
    "summary": "在 JavaScript 中，存在一些异步操作，需要等浏览器执行完成之后，再告诉主线程，我们再去做后续的操作 之前为了实现这一点，我们会用回调函数的方式，拿到异步的执行结果，并做后续处理 但如果我们在某一个回调函数中，又依赖其他回调函数带过来的参数，就会存在回调地狱（混乱的嵌套），且难以维护和控制状态，由此 es6 引入了 Promise 的概念。一个 Promise 本身只有三种状态，pendi...",
    "content": "在 JavaScript 中，存在一些异步操作，需要等浏览器执行完成之后，再告诉主线程，我们再去做后续的操作\n之前为了实现这一点，我们会用回调函数的方式，拿到异步的执行结果，并做后续处理\n但如果我们在某一个回调函数中，又依赖其他回调函数带过来的参数，就会存在回调地狱（混乱的嵌套），且难以维护和控制状态，由此 es6 引入了 Promise 的概念。一个 Promise 本身只有三种状态，pending（待定），fulfilled（成功），rejected（失败），当状态从待定，变成成功或失败后，状态将固定不再发生变化。它支持链式调用，then 和 catch 方法总会返回一个新的 promise 对象，从而将嵌套的回调拉平，且可以将状态通过链式传递下去。\n如果then中的回调函数：\n返回了一个值（包括另一个Promise），那么新返回的Promise会以这个值作为成功状态的结果。\n没有返回值，新返回的Promise会以undefined作为成功状态的结果。\n抛出了错误，新返回的Promise则会变为失败状态。\n而 Async 和 Await，则是Promise 的语法糖，通过它，我们可以使用同步的代码写法，实现异步的功能。一个函数被async关键字修饰后，​它无论如何都会返回一个Promise对象。\n如果函数内显式返回一个非Promise值，这个值会被自动包装成一个已解决的Promise；\n如果函数抛出异常，则会返回一个被拒绝的Promise。\n如何使用它？\n解决了什么问题？\nPromise 解决了回调地狱，便于管理状态。Async/Await 让异步处理可以跟同步一样，使代码逻辑更清晰\n最佳实践有哪些？\n无依赖的异步任务使用 Promise.all并行执行提升效率\n手动处理接口超时，可以定义一个超时Promise（比如限定 30s 后，返回失败），使用 Promise.race([])，将实际接口请求，和超时 Promise 都放进去，让它们\"竞速\"\n在使用 async/await 的时候，一定要用 try/catch 做错误处理\nPromise 链中必须使用 catch 做错误处理",
    "tags": [
      "Promise",
      "async/await"
    ],
    "date": "2025-10-21",
    "readingTime": "4 min read",
    "url": "/blog/异步编程",
    "searchText": "异步编程 在 JavaScript 中 存在一些异步操作 需要等浏览器执行完成之后 再告诉主线程 我们再去做后续的操作 之前为了实现这一点 我们会用回调函数的方式 拿到异步的执行结果 并做后续处理 但如果我们在某一个回调函数中 又依赖其他回调函数带过来的参数 就会存在回调地狱 混乱的嵌套 且难以维护和控制状态 由此 es6 引入了 Promise 的概念 一个 Promise 本身只有三种状态 pending 待定 fulfilled 成功 rejected 失败 当状态从待定 变成成功或失败后 状态将固定不再发生变化 它支持链式调用 then 和 catch 方法总会返回一个新的 promise 对象 从而将嵌套的回调拉平 且可以将状态通过链式传递下去 如果then中的回调函数 返回了一个值 包括另一个Promise 那么新返回的Promise会以这个值作为成功状态的结果 没有返回值 新返回的Promise会以undefined作为成功状态的结果 抛出了错误 新返回的Promise则会变为失败状态 而 Async 和 Await 则是Promise 的语法糖 通过它 我们可以使用同步的代码写法 实现异步的功能 一个函数被async关键字修饰后 它无论如何都会返回一个Promise对象 如果函数内显式返回一个非Promise值 这个值会被自动包装成一个已解决的Promise 如果函数抛出异常 则会返回一个被拒绝的Promise 如何使用它 解决了什么问题 Promise 解决了回调地狱 便于管理状态 Async Await 让异步处理可以跟同步一样 使代码逻辑更清晰 最佳实践有哪些 无依赖的异步任务使用 Promise all并行执行提升效率 手动处理接口超时 可以定义一个超时Promise 比如限定 30s 后 返回失败 使用 Promise race 将实际接口请求 和超时 Promise 都放进去 让它们 竞速 在使用 async await 的时候 一定要用 try catch 做错误处理 Promise 链中必须使用 catch 做错误处理"
  },
  {
    "id": "模块化开发",
    "title": "模块化开发",
    "summary": "模块化开发指的是，在前端开发过程中，每个模块都是独立的单元，我们通过封装变量（如ESM的独立作用域），避免全局暴露，从而实现变量隔离避免全局污染。这样在代码修改时，可以更好的控制影响范围，且提高了复用性。 当前已有的实现包括 CommonJS，AMD，CMD，UMD，ESM 1. CommonJS 是同步加载的（适合服务器启动时做预处理），在 Node 环境下使用 2. AMD 异步加载（避免浏览...",
    "content": "模块化开发指的是，在前端开发过程中，每个模块都是独立的单元，我们通过封装变量（如ESM的独立作用域），避免全局暴露，从而实现变量隔离避免全局污染。这样在代码修改时，可以更好的控制影响范围，且提高了复用性。\n当前已有的实现包括 CommonJS，AMD，CMD，UMD，ESM\nCommonJS 是同步加载的（适合服务器启动时做预处理），在 Node 环境下使用\nAMD 异步加载（避免浏览器阻塞），提供给老旧浏览器\nCMD 异步加载，提供给浏览器使用，已逐步淘汰\nUMD 在Node 同步加载，浏览器环境异步加载，用于兼容旧环境\nESM 是官方模块化规范，在Node 同步加载，浏览器环境异步加载，且支持静态优化\n如何使用？\n当前情况下，我们使用的都是 ESM，通过 import 导入模块，export 导出模块\n解决什么问题？\n模块化开发可以解决代码之间变量名，函数名的冲突 / 污染的情况，降低代码之间的耦合关系，提高代码复用性、可维护性。\n模块化让团队开发者能并行开发独立模块（通过 npm 包管理），通过接口约定减少冲突。此外可以显著提升单元测试和自动化部署效率（仅测试/部署修改的部分，提高效率，降低风险）。\n最佳实践\n模块设计时遵循单一职责（比如拆分 UI 组件和数据组件），高内聚低耦合（模块内部功能紧密相关，模块间通过接口通信），开放封闭，依赖倒置的设计原则\nESM 的 import/export 使得 webpack 等工具在编译时可以分析依赖关系（CommonJS 的 require 在运行时加载，难以静态分析），从而进行 Tree Shaking，将未使用的代码提前移除，只引入需要的代码，减少代码体积。\n通过代码分割，动态import()将路由页面拆分为独立块，可以实现更好的按需加载。\n在分布式架构中的应用：在微前端中，将应用拆分为独立的子应用，实现独立的开发和部署",
    "tags": [
      "CommonJS",
      "AMD",
      "CMD",
      "UMD",
      "ESM"
    ],
    "date": "2025-10-22",
    "readingTime": "3 min read",
    "url": "/blog/模块化开发",
    "searchText": "模块化开发 模块化开发指的是 在前端开发过程中 每个模块都是独立的单元 我们通过封装变量 如ESM的独立作用域 避免全局暴露 从而实现变量隔离避免全局污染 这样在代码修改时 可以更好的控制影响范围 且提高了复用性 当前已有的实现包括 CommonJS AMD CMD UMD ESM CommonJS 是同步加载的 适合服务器启动时做预处理 在 Node 环境下使用 AMD 异步加载 避免浏览器阻塞 提供给老旧浏览器 CMD 异步加载 提供给浏览器使用 已逐步淘汰 UMD 在Node 同步加载 浏览器环境异步加载 用于兼容旧环境 ESM 是官方模块化规范 在Node 同步加载 浏览器环境异步加载 且支持静态优化 如何使用 当前情况下 我们使用的都是 ESM 通过 import 导入模块 export 导出模块 解决什么问题 模块化开发可以解决代码之间变量名 函数名的冲突 污染的情况 降低代码之间的耦合关系 提高代码复用性 可维护性 模块化让团队开发者能并行开发独立模块 通过 npm 包管理 通过接口约定减少冲突 此外可以显著提升单元测试和自动化部署效率 仅测试 部署修改的部分 提高效率 降低风险 最佳实践 模块设计时遵循单一职责 比如拆分 UI 组件和数据组件 高内聚低耦合 模块内部功能紧密相关 模块间通过接口通信 开放封闭 依赖倒置的设计原则 ESM 的 import export 使得 webpack 等工具在编译时可以分析依赖关系 CommonJS 的 require 在运行时加载 难以静态分析 从而进行 Tree Shaking 将未使用的代码提前移除 只引入需要的代码 减少代码体积 通过代码分割 动态import 将路由页面拆分为独立块 可以实现更好的按需加载 在分布式架构中的应用 在微前端中 将应用拆分为独立的子应用 实现独立的开发和部署"
  },
  {
    "id": "浏览器缓存",
    "title": "浏览器缓存",
    "summary": "localStorage：浏览器前端本地缓存，当页面关闭的时候，不会自动清空，可以存 5MB，且共享给其他标签一起使用 sessionStorage：会话级别的浏览器前端本地缓存，当会话关闭的时候（tab 页关闭），自动清空，且不共享给其他标签 cookie：前后端都可以使用的缓存，一般用来存储鉴权信息，或者用于分析用户习惯的相关数据，可以通过多个属性控制它（比如允许使用的接口域名/path 控制...",
    "content": "localStorage：浏览器前端本地缓存，当页面关闭的时候，不会自动清空，可以存 5MB，且共享给其他标签一起使用\nsessionStorage：会话级别的浏览器前端本地缓存，当会话关闭的时候（tab 页关闭），自动清空，且不共享给其他标签\ncookie：前后端都可以使用的缓存，一般用来存储鉴权信息，或者用于分析用户习惯的相关数据，可以通过多个属性控制它（比如允许使用的接口域名/path 控制携带范围，是否允许前端读取 httponly，过期时间，优先级，安全相关的控制字段，httponly、secure等属性可以防止XSS攻击），有4KB大小限制且自动发送到服务器\nIndexedDB：前端数据库，可以用来存储大型数据，比如离线应用存大量文档数据文档，支持索引，同时也带来了复杂性（如异步API、事务处理）\n共同点：都是浏览器用来缓存数据的，受同源策略的保护\n如何使用？\nlocalStorage.getItem/setItem\nsessionStorage.getItem/setItem\nCookie 的操作最好使用一个封装库，纯字符串不好处理\n解决什么问题？\nlocalStorage 可以用来存一些系统/用户的默认配置数据（比如默认展示哪些模块）\nsessionStorage 可以用来存一些临时数据，即用即丢的（比如当前页面的草稿内容）\nCookie 通过丰富的控制项，主要用来处理前后端的鉴权\nIndexedDB 可以处理大型数据\n最佳实践\nCookie 中的鉴权信息，一般通过后端配置，其通过多个配置项，不允许前端读取，不允许跨域的页面读取。当发出的接口请求不匹配 path 时，请求头中将不会携带对应的字段\n注意存储的大小，一般都要转为 JSON 字符串后，再存\n大数据用 IndexedDB，避免localStorage超5MB限制\n会话级数据用 sessionStorage，减少内存占用",
    "tags": [
      "localStorage",
      "sessionStorage",
      "cookie",
      "IndexedDB",
      "Cache"
    ],
    "date": "2025-10-21",
    "readingTime": "3 min read",
    "url": "/blog/浏览器缓存",
    "searchText": "浏览器缓存 localStorage 浏览器前端本地缓存 当页面关闭的时候 不会自动清空 可以存 5MB 且共享给其他标签一起使用 sessionStorage 会话级别的浏览器前端本地缓存 当会话关闭的时候 tab 页关闭 自动清空 且不共享给其他标签 cookie 前后端都可以使用的缓存 一般用来存储鉴权信息 或者用于分析用户习惯的相关数据 可以通过多个属性控制它 比如允许使用的接口域名 path 控制携带范围 是否允许前端读取 httponly 过期时间 优先级 安全相关的控制字段 httponly secure等属性可以防止XSS攻击 有4KB大小限制且自动发送到服务器 IndexedDB 前端数据库 可以用来存储大型数据 比如离线应用存大量文档数据文档 支持索引 同时也带来了复杂性 如异步API 事务处理 共同点 都是浏览器用来缓存数据的 受同源策略的保护 如何使用 localStorage getItem setItem sessionStorage getItem setItem Cookie 的操作最好使用一个封装库 纯字符串不好处理 解决什么问题 localStorage 可以用来存一些系统 用户的默认配置数据 比如默认展示哪些模块 sessionStorage 可以用来存一些临时数据 即用即丢的 比如当前页面的草稿内容 Cookie 通过丰富的控制项 主要用来处理前后端的鉴权 IndexedDB 可以处理大型数据 最佳实践 Cookie 中的鉴权信息 一般通过后端配置 其通过多个配置项 不允许前端读取 不允许跨域的页面读取 当发出的接口请求不匹配 path 时 请求头中将不会携带对应的字段 注意存储的大小 一般都要转为 JSON 字符串后 再存 大数据用 IndexedDB 避免localStorage超5MB限制 会话级数据用 sessionStorage 减少内存占用"
  },
  {
    "id": "浏览器跨域",
    "title": "浏览器跨域",
    "summary": "这篇我们来关注浏览器跨域 浏览器跨域是什么？ 跨域请求拦截是浏览器为了请求安全引入的基于同源策略实现的安全特性，当用户在一个页面上（baidu.com）尝试请求另一个来源的数据(api.baidu.com)时，如果协议、域名、端口号任意不同，守卫就会拦截请求 如何触发浏览器跨域？ 当发出请求的协议，域名，端口号任意一个跟当前页面不一致时，则会出现跨域请求拦截。 浏览器跨域有什么用？ 同源策略限制了...",
    "content": "这篇我们来关注浏览器跨域\n浏览器跨域是什么？\n跨域请求拦截是浏览器为了请求安全引入的基于同源策略实现的安全特性，当用户在一个页面上（baidu.com）尝试请求另一个来源的数据(api.baidu.com)时，如果协议、域名、端口号任意不同，守卫就会拦截请求\n如何触发浏览器跨域？\n当发出请求的协议，域名，端口号任意一个跟当前页面不一致时，则会出现跨域请求拦截。\n浏览器跨域有什么用？\n同源策略限制了浏览器无法跨域读取 Cookie/LocalStorage/SessionStorage 或操作 DOM，主要为防止恶意网站窃取隐私。例如，你登录网银后访问黑客网站，若无同源策略，黑客可能用你的Cookie冒充操作。\n浏览器跨域的最佳实践？\nCORS，通过预检机制（类似签证制度，有的国家需要申请，有的国家免签），将请求分为简单请求和需预检请求，如果是简单请求，直接处理。如果是复杂请求，先发出一个预检请求OPTIONS，就像申请签证，通过后才执行真实请求。\n为什么要有预检机制？\n  比如用户想发起 DELETE/PUT 等非简单请求操作，可能会直接操作数据，所以需要浏览器通过预检请求确认后端服务是否支持用户操作。\n预检机制如何区分普通请求和预检请求？\n  普通请求：1. 请求方法只能是 GET/HEAD/POST 2. Content-Type 仅支持：application/x-www-form-urlencoded、multipart/form-data、text/plain 3. 浏览器会检查请求头和方法的\"安全性\"，任何非标准行为（如添加Authorization头）都会触发预检请求\nCORS 具体如何实现？\n  后端在收到预检请求的时候，在响应头中加入 Access-Control-Allow-\\.\n跨域请求拦截是浏览器的限制，如果通过 nginx 反向代理（类似菜鸟驿站转交快递，用户无需直接面对快递员）转发可以解决\n通过浏览器插件或者禁用其安全特性，也可在开发阶段解决跨域问题\n其它方案，postMessage（跨窗口 iframe 通信），JSONP（只支持 GET）\n如果 canvas 无法读取和导出图片，通过 window.onerror 统计错误时，只有 Script Error，都表示跟跨域相关，需要设置 crossorigin=\"anonymous\"，（",
    "tags": [
      "CORS",
      "network",
      "browser",
      "nginx"
    ],
    "date": "2025-10-20",
    "readingTime": "5 min read",
    "url": "/blog/浏览器跨域",
    "searchText": "浏览器跨域 这篇我们来关注浏览器跨域 浏览器跨域是什么 跨域请求拦截是浏览器为了请求安全引入的基于同源策略实现的安全特性 当用户在一个页面上 baidu com 尝试请求另一个来源的数据 api baidu com 时 如果协议 域名 端口号任意不同 守卫就会拦截请求 如何触发浏览器跨域 当发出请求的协议 域名 端口号任意一个跟当前页面不一致时 则会出现跨域请求拦截 浏览器跨域有什么用 同源策略限制了浏览器无法跨域读取 Cookie LocalStorage SessionStorage 或操作 DOM 主要为防止恶意网站窃取隐私 例如 你登录网银后访问黑客网站 若无同源策略 黑客可能用你的Cookie冒充操作 浏览器跨域的最佳实践 CORS 通过预检机制 类似签证制度 有的国家需要申请 有的国家免签 将请求分为简单请求和需预检请求 如果是简单请求 直接处理 如果是复杂请求 先发出一个预检请求OPTIONS 就像申请签证 通过后才执行真实请求 为什么要有预检机制 比如用户想发起 DELETE PUT 等非简单请求操作 可能会直接操作数据 所以需要浏览器通过预检请求确认后端服务是否支持用户操作 预检机制如何区分普通请求和预检请求 普通请求 1 请求方法只能是 GET HEAD POST 2 Content Type 仅支持 application x www form urlencoded multipart form data text plain 3 浏览器会检查请求头和方法的 安全性 任何非标准行为 如添加Authorization头 都会触发预检请求 CORS 具体如何实现 后端在收到预检请求的时候 在响应头中加入 Access Control Allow 跨域请求拦截是浏览器的限制 如果通过 nginx 反向代理 类似菜鸟驿站转交快递 用户无需直接面对快递员 转发可以解决 通过浏览器插件或者禁用其安全特性 也可在开发阶段解决跨域问题 其它方案 postMessage 跨窗口 iframe 通信 JSONP 只支持 GET 如果 canvas 无法读取和导出图片 通过 window onerror 统计错误时 只有 Script Error 都表示跟跨域相关 需要设置 crossorigin anonymous 对于需要凭证的图片 需要设置crossorigin use credentials 且响应头添加 Access Control Allow Origin 扩展内容 反向代理如何配置 细节 Nginx反向代理配置中 proxy_pass后是否有斜杠会影响URL重写规则 例如proxy_pass http api example com 会将 api user转发为http api example com user 而无斜杠则会保留 api路径 配置 chrome 禁用跨域 disable web security user data dir 任意文件夹路径"
  },
  {
    "id": "聊聊前端工程化-AI版本",
    "title": "聊聊前端工程化-AI版本",
    "summary": "从前端“手工作坊”到“现代工厂”：前端工程化核心实践与演进思考 当我们谈论前端工程化时，它描绘的是一幅从无序到有序，从个人技艺到系统工程的进化图谱。这如同建造摩天大楼，不仅需要一砖一瓦的匠心（编码能力），更需要科学的规划设计（规范与设计）、高效的供应链管理（依赖与构建）、严谨的施工流程（自动化与部署）以及持续的健康监测（监控与优化）。本文旨在系统梳理前端工程化的核心支柱，并分享如何在项目演进中持续...",
    "content": "从前端“手工作坊”到“现代工厂”：前端工程化核心实践与演进思考\n当我们谈论前端工程化时，它描绘的是一幅从无序到有序，从个人技艺到系统工程的进化图谱。这如同建造摩天大楼，不仅需要一砖一瓦的匠心（编码能力），更需要科学的规划设计（规范与设计）、高效的供应链管理（依赖与构建）、严谨的施工流程（自动化与部署）以及持续的健康监测（监控与优化）。本文旨在系统梳理前端工程化的核心支柱，并分享如何在项目演进中持续应用这些实践。\n一、规范先行：奠定可维护、可协作的基石\n规范是工程化的首要前提，其价值在于用最小的成本换取长期的可维护性和团队协作效率。它应是一个多层次、可执行的标准体系。\n代码规范与自动化检查：利用 ESLint 进行静态代码检查，配合 Prettier 实现代码风格的自动格式化，是项目的标准配置。关键在于将规范检查“强绑定”到开发流程中。通过 Husky 设置 Git Hooks（如  钩子），可以实现增量代码检查，仅对本次提交的改动文件进行扫描，从而在保障代码质量的同时，极大提升开发效率，避免每次提交都进行全量检查的漫长等待。\n提交规范与组件文档：采用类似 Angular 规范的提交消息格式（如 , ），可以使提交历史清晰可循。对于组件库，应提供清晰的 API 文档 和 TypeScript 类型定义，明确参数含义、是否必填、关联效应等，这能极大降低组件的使用成本和沟通损耗。\n架构规范：制定目录结构、模块拆分、接口设计等高层规范，有助于在项目初期建立清晰的代码边界，防止项目随着复杂度提升而演变为“意大利面条式”代码。\n二、模块化与组件化：构建高内聚、低耦合的架构\n模块化和组件化是管理复杂性的核心手段，它们共同构筑了前端应用的骨架。\n模块化演进与构建优化\nJavaScript 模块化经历了从“全局变量污染”到 CommonJS/AMD，再到 ES Modules (ESM) 的演进。ESM 已成为现代前端的事实标准，它带来的不仅是统一的语法，更是Tree Shaking 和按需加载等优化技术的基础。通过  管理依赖，结合构建工具（如 Webpack、Vite、Rollup）的代码分割（Code Splitting）功能，可以实现路由级甚至组件级的按需加载，有效控制首屏资源体积。\n组件化设计的心智模型\n组件化不应仅仅是技术的封装，更是功能的抽象。在设计一个组件时，需要明确",
    "tags": [],
    "date": "2025-11-14",
    "readingTime": "11 min read",
    "url": "/blog/聊聊前端工程化-AI版本",
    "searchText": "聊聊前端工程化 AI版本 从前端 手工作坊 到 现代工厂 前端工程化核心实践与演进思考 当我们谈论前端工程化时 它描绘的是一幅从无序到有序 从个人技艺到系统工程的进化图谱 这如同建造摩天大楼 不仅需要一砖一瓦的匠心 编码能力 更需要科学的规划设计 规范与设计 高效的供应链管理 依赖与构建 严谨的施工流程 自动化与部署 以及持续的健康监测 监控与优化 本文旨在系统梳理前端工程化的核心支柱 并分享如何在项目演进中持续应用这些实践 一 规范先行 奠定可维护 可协作的基石 规范是工程化的首要前提 其价值在于用最小的成本换取长期的可维护性和团队协作效率 它应是一个多层次 可执行的标准体系 代码规范与自动化检查 利用 ESLint 进行静态代码检查 配合 Prettier 实现代码风格的自动格式化 是项目的标准配置 关键在于将规范检查 强绑定 到开发流程中 通过 Husky 设置 Git Hooks 如 钩子 可以实现增量代码检查 仅对本次提交的改动文件进行扫描 从而在保障代码质量的同时 极大提升开发效率 避免每次提交都进行全量检查的漫长等待 提交规范与组件文档 采用类似 Angular 规范的提交消息格式 如 可以使提交历史清晰可循 对于组件库 应提供清晰的 API 文档 和 TypeScript 类型定义 明确参数含义 是否必填 关联效应等 这能极大降低组件的使用成本和沟通损耗 架构规范 制定目录结构 模块拆分 接口设计等高层规范 有助于在项目初期建立清晰的代码边界 防止项目随着复杂度提升而演变为 意大利面条式 代码 二 模块化与组件化 构建高内聚 低耦合的架构 模块化和组件化是管理复杂性的核心手段 它们共同构筑了前端应用的骨架 模块化演进与构建优化 JavaScript 模块化经历了从 全局变量污染 到 CommonJS AMD 再到 ES Modules ESM 的演进 ESM 已成为现代前端的事实标准 它带来的不仅是统一的语法 更是Tree Shaking 和按需加载等优化技术的基础 通过 管理依赖 结合构建工具 如 Webpack Vite Rollup 的代码分割 Code Splitting 功能 可以实现路由级甚至组件级的按需加载 有效控制首屏资源体积 组件化设计的心智模型 组件化不应仅仅是技术的封装 更是功能的抽象 在设计一个组件时 需要明确其单一职责 它要完成什么核心功能 它需要哪些数据 Props 它会产生哪些副作用 Side Effects 对于复杂组件 尤其要注意生命周期的管理 例如 在组件中发起异步请求时 必须在组件卸载时进行清理 防止内存泄漏 一个良好的组件应该如同一台精密的仪器 接口清晰 功能内聚 与外部环境解耦 三 自动化 提升交付效率与质量的引擎 工程化的目标是让开发者专注于业务创新 而非重复劳动 自动化是实现这一目标的关键 持续集成与持续交付 CI CD 利用 Jenkins GitHub Actions 等工具 实现代码提交后自动触发构建 测试 部署流程 这不仅能杜绝人工操作失误 如刷错包 更实现了快速 可靠的交付 自动化测试 构建从单元测试 Jest 针对工具函数 纯逻辑 组件测试 Testing Library 针对UI组件交互 到端到端测试 Cypress 针对完整用户流程 的多层次测试体系 测试的核心价值在于为重构和优化提供安全网 确保变更不会引入未知的回归问题 基础设施自动化 将环境配置 依赖安装等步骤脚本化 实现开发 测试 生产环境的一致性 解决 在我这儿是好的 经典难题 四 性能优化 贯穿始终的用户体验追求 性能优化不是一次性的运动 而应内化为开发过程中的一种习惯 它遵循 测量 定位 优化 验证 的闭环 下面的表格梳理了不同阶段的优化策略与衡量标准 优化阶段 核心目标 关键实践 衡量指标 构建与传输 减少资源体积 加快交付速度 Tree Shaking 代码分割 br 压缩 JS CSS 图片 br 利用 ESM 和现代构建工具 如 Vite 提升冷启动速度 br 开启 GZIP Brotli 压缩 打包体积 模块数量 网络与加载 缩短资源加载时间 提升首屏体验 HTTP 2 CDN 加速 br 利用强缓存与协商缓存 br 关键资源预加载 预连接 br 非核心资源懒加载 图片 iframe 首次内容绘制 FCP 最大内容绘制 LCP 运行时与渲染 保证界面流畅 响应迅速 避免强制同步布局 重排 br 使用 和 的属性实现动画 br 虚拟列表 表格应对大数据渲染 br 复杂计算放入 Web Worker 累积布局偏移 CLS 首次输入延迟 FID 性能优化的前提是测量 没有数据支撑的优化是盲目的 应接入 性能监控平台 如 Lighthouse Web Vitals 在生产环境中持续收集真实用户数据 从而精准定位瓶颈 指导优化方向 五 质量保障与监控 构建系统稳定性的护城河 一个健壮的系统必须具备快速发现问题 定位问题和解决问题的能力 前端监控体系 建设完善的监控系统 涵盖错误监控 JS异常 资源加载失败 API请求异常 性能监控 核心 Web Vitals 指标 和行为监控 用户关键路径打点 当白屏 接口报错等问题发生时 监控系统应能提供完整的上下文信息 用户环境 操作轨迹 错误堆栈 助力快速复现和修复 数据驱动的决策 监控数据不仅能用于 救火 更能用于 防火 通过分析用户行为数据 了解功能的真实使用情况 为新功能迭代或旧功能优化提供决策依据 让技术工作真正产生业务价值 总结 工程化是一场永无止境的演进 前端工程化并非一劳永逸地引入一堆工具 而是一个随着团队规模和项目复杂度不断提升 而持续演进和优化的过程 其核心在于 通过规范化降低协作成本 通过模块化 组件化管理复杂性 通过自动化提升效率 通过性能优化保障体验 通过质量监控确保稳定 最好的工程化实践是 透明 的 它如同大楼的电力系统和给排水系统 平时默默无闻 却为业务的持续创新提供着不竭的动力 让我们从当前项目的痛点出发 选择一个最小的可行方案 MVP 开始实践 逐步构建起适合自身团队的前端工程化体系 从而从容应对未来的挑战"
  },
  {
    "id": "聊聊前端工程化-人工版本",
    "title": "聊聊前端工程化-人工版本",
    "summary": "前端工程化是一个很大的词，就像让你去盖一栋楼，前期的规划设计，方案验证，再到原材料购买，协调人力，工期管理，验收交付等。可以发现前端开发从某种程度上来说，跟你去盖楼没啥本质区别，有时候你可能是需要盖一栋新楼（从 0 到 1 的新需求），而有时候你可能是需要在盖了一半的楼上继续施工（基于已有项目，再开发新功能），你也可能被安排去修修电路，管道啥的（修复一个已有问题）。 那么具体到前端工程化，有哪些我...",
    "content": "前端工程化是一个很大的词，就像让你去盖一栋楼，前期的规划设计，方案验证，再到原材料购买，协调人力，工期管理，验收交付等。可以发现前端开发从某种程度上来说，跟你去盖楼没啥本质区别，有时候你可能是需要盖一栋新楼（从 0 到 1 的新需求），而有时候你可能是需要在盖了一半的楼上继续施工（基于已有项目，再开发新功能），你也可能被安排去修修电路，管道啥的（修复一个已有问题）。\n那么具体到前端工程化，有哪些我们值得关注的点呢？\n从前端发展的角度看，从最开始的原生 html+JavaScript+CSS，到 jQuery 时代，再到 Vue+React，再到如今 Vite 引领的模块化开发。可以发现，前端做了原来越多的事情，也变得越来越复杂，在这个过程中，每当有人发现 \"哎呀，这个东西难搞死了，我得想办法处理下\"，就会出现一个新的工具，背后其实是一种新的思维或者说思想。这篇文章，我不想写成考古文，我想讨论下当前有哪些地方我们可以关注。\n在前端工程化中，最基础，也是代价最小的，我想是\"规范\"。\n从微观角度，一个函数的具体实现，一个接口的定义。再到宏观角度，整个项目的开发规范。这些东西如果能在项目一开始就有一个基础的设计，那么性价比将爆炸的高。从实践角度来说，先引入 ESLint/Prettier 保证代码风格的统一，以及配置 commit 阶段和入库阶段的 eslint 检查，都属于一次配置终身受益的必选项。再深入一些，到具体的代码层面，针对有些复杂的函数/接口，有没有一套\"规范\"来\"限制\"开发人员，比如函数入参不能太多，组件对外暴漏的参数是否含义明确（是否是必填项？不同参数之间是否有关联效果？）。一个函数或者一个接口，它承载的功能是否太多？或者它承载的功能是否太少？其实我自己并不是每次都要一个最优解，但如果在写代码的时候，稍微多想一下，可能就会写出更优雅的代码。（或者简单粗暴一些，对于你自己拿不准的东西，抽象以后问一下 AI 吧，它总会给你一个不错的答案）\n在规范之后，我想到的是模块化\n我们先来聊聊模块化，这里又涉及到 JavaScript 模块化，CSS 模块化以及其它资源的模块化。在 JavaScript 中，只要你的项目稍微复杂一些，那必然要面临代码拆分/复用的问题，全局变量更是难题，说不定业务堆着堆着你就发现 A 依赖 B，B 依赖 C，C 又依赖 A，原地爆炸了。那么我",
    "tags": [],
    "date": "2025-11-14",
    "readingTime": "26 min read",
    "url": "/blog/聊聊前端工程化-人工版本",
    "searchText": "聊聊前端工程化 人工版本 前端工程化是一个很大的词 就像让你去盖一栋楼 前期的规划设计 方案验证 再到原材料购买 协调人力 工期管理 验收交付等 可以发现前端开发从某种程度上来说 跟你去盖楼没啥本质区别 有时候你可能是需要盖一栋新楼 从 0 到 1 的新需求 而有时候你可能是需要在盖了一半的楼上继续施工 基于已有项目 再开发新功能 你也可能被安排去修修电路 管道啥的 修复一个已有问题 那么具体到前端工程化 有哪些我们值得关注的点呢 从前端发展的角度看 从最开始的原生 html JavaScript CSS 到 jQuery 时代 再到 Vue React 再到如今 Vite 引领的模块化开发 可以发现 前端做了原来越多的事情 也变得越来越复杂 在这个过程中 每当有人发现 哎呀 这个东西难搞死了 我得想办法处理下 就会出现一个新的工具 背后其实是一种新的思维或者说思想 这篇文章 我不想写成考古文 我想讨论下当前有哪些地方我们可以关注 在前端工程化中 最基础 也是代价最小的 我想是 规范 从微观角度 一个函数的具体实现 一个接口的定义 再到宏观角度 整个项目的开发规范 这些东西如果能在项目一开始就有一个基础的设计 那么性价比将爆炸的高 从实践角度来说 先引入 ESLint Prettier 保证代码风格的统一 以及配置 commit 阶段和入库阶段的 eslint 检查 都属于一次配置终身受益的必选项 再深入一些 到具体的代码层面 针对有些复杂的函数 接口 有没有一套 规范 来 限制 开发人员 比如函数入参不能太多 组件对外暴漏的参数是否含义明确 是否是必填项 不同参数之间是否有关联效果 一个函数或者一个接口 它承载的功能是否太多 或者它承载的功能是否太少 其实我自己并不是每次都要一个最优解 但如果在写代码的时候 稍微多想一下 可能就会写出更优雅的代码 或者简单粗暴一些 对于你自己拿不准的东西 抽象以后问一下 AI 吧 它总会给你一个不错的答案 在规范之后 我想到的是模块化 我们先来聊聊模块化 这里又涉及到 JavaScript 模块化 CSS 模块化以及其它资源的模块化 在 JavaScript 中 只要你的项目稍微复杂一些 那必然要面临代码拆分 复用的问题 全局变量更是难题 说不定业务堆着堆着你就发现 A 依赖 B B 依赖 C C 又依赖 A 原地爆炸了 那么我们肯定不希望自己一个一个去给模块做区分 而是想有一个工具 让模块变得 唯一 这时候就需要看下JavaScript模块化的发展了 刚开始是 CommonJS 给 Node 环境用的 同步加载 然后中间出现了 AMD 给浏览器用的 异步加载 CMD 给浏览器用的 异步加载 UMD 在 Node 环境下是同步的 在浏览器环境下是异步的 到了 ES6 之后 我们可以直接使用 ESM 了 它支持浏览器和 Node 环境 变成了事实意义上的标准 用起来更是方面 import export 就可以了 有了 ESM 才让 tree shaking 和模块懒加载成为了可能 在 CSS 模块化方面 我的实践不多 最常见的问题可能是你想修改你引入的组件库 elementUI antdUI semiUI 中组件的样式 比如把按钮背景色改改之类的 这里我们一般会在一个新增的 less scss 中通过 的方式进行样式覆盖 这里有时会埋下大坑 比如你没有限定好修改范围 把全局的样式都改了 尤其你临时修复一个线上样式问题 本来一个小错误 搞成了大问题 或者由于优先级的问题 导致样式不生效等 解决方法也很简单 写样式的时候 时刻问自己 我写的这段 css 选择器是不是已经是最精准的了 此外其它的资源 图片 字体等 一般我们会通过 webpack loader 之类的工具 处理为可以识别和进一步操作的模块 接下来聊聊组件化的问题 在使用 Vue React 框架的时候 我们经常说 我把这个功能封装了一个组件 那么组件化是什么 他又有哪些值得我们关注的地方呢 从大的角度来看 我们在浏览器中看到的是一个完整的页面 而构成这个页面的 往往会包含导航栏 详情内容 底部信息栏等方面 然后任意一个板块 比如详情内容中 可能又包括了图片展示 文字展示的内容 如果说页面的最小单位是一个 DOM 那组件就是一系列关联 DOM 的封装 一个组件可大可小 它的功能可能就是一个鉴权跳转 也可能是整个页面 那么我们在设计一个组件的时候 需要关注哪些东西呢 不管是 UI 组件还是自定义 hook 组件 最最基础的 我们应该找准这个组件的功能定位 它具体要实现什么功能 为了实现这个功能 它需要哪些前置条件 前置条件是通过外层传入的数据就可以了吗 比如一个纯 UI 组件 还是说它自己也要做一些更复杂的逻辑处理呢 比如一个表格组件 其中有一列需要前端自己去做计算 它要不要考虑迁移到其它页面 项目后的适配问题 在这些考虑清楚后 我们再看细节一点 比如这个组件的入参要怎么设计 这块又跟上面说的 规范 关联起来了 在组件内部如果有副作用操作 是否需要考虑回退 以及手动的销毁 一个典型但又很烦人的场景 你在一个组件中 需要异步初始化一个实例 然后在初始化完成 组件销毁前 也把相关示例销毁掉 看起来逻辑普普通通 但里面有个大坑 异步初始化 当实例的异步初始化还没完成 实例所在的组件就销毁了咋办 那实例将会变成凤凰传奇中曾毅的经典歌词 留下来 当这个操作稍微多起来 那么内存爆涨 CPU 打满 直到页面卡死崩溃 然后我被公司开除 bushi 还是那句话 我们可能很难写出一个完美的组件 但可以多想想 多试试 聊完上面这些 我想谈谈性能优化 一说起性能优化 前端翻来覆去就是那些东西 我们只要按照最佳实践 把每一步都做到位了 就没啥问题了 如果真的遇到工程上非常复杂的性能问题 那还是需要单独分析 从我的角度来看 就那几个方面吧 1 性能检测 接入检测平台 本地性能验证 2 网络请求阶段优化 3 静态资源优化 4 前端代码架构优化 5 渲染优化 6 用户体验优化 性能优化的前提是监测 在我的本科生涯中 可能最重要的一个知识点就是在自动控制原理这门课中学到的 没有反馈就没有控制 同样在性能优化上 你得先通过监测结果 知道性能的瓶颈在什么地方 是静态资源太大了 是接口请求太多卡死了 是涉及到很多复杂逻辑计算 让浏览器的单线程扛不住了 等等等等吧 我们先把关键的阻塞点找到 然后再看具体的解决方案 具体来说 在网络请求阶段 前端能做的事情不算太多 大多是后端或者运维去处理的 比如开启 GZIP 压缩 开始 HTTP2 强缓存和协商缓存 针对第三方库提供 CDN 访问服务等 前端可以关注下 有哪些接口可以合并 比如用户进入页面后 是不是需要查询一堆配置项 能合成一个吗 将支持的三方库换为 CDN 访问方式 以及做服务器的预连接和域名的预解析 主要也是针对三方 然后在静态资源优化上 生产环境使用压缩后的东西 这里面包括了利用 webpack 的 terser 去压缩代码 图片 尤其是svg 等 这里重点关注下图片和字体的格式 图片里面用 avif webp jpeg png 做优雅降级 字体里面用 woff2 woff ttf 做优雅降级 有了这些基础 再做一些的 tree shaking 效果就比较明显了 到了具体的代码层面 有一些需要小心的地方 比如不要在循环中操作 DOM 在使用 css 选择器的时候 尽可能的精准 比如你在一个复杂页面汇总 搞几次 querySelectorAll 查一堆元素 页面不卡死算我输 然后尽量避免重绘重排 在组件 定时器 实例 事件监听卸载的地方 尤其注意跟异步组合后 会不会有卸载失败的情况 使用浏览器提供的 localStorage sessionStorage Cookie 以及 ES6 提供的单例模式 合理存储和消费数据 避免通过接口重复获取数据 针对复杂计算的场景 我们可以缓存计算结果 比如在 react 中使用 useMemo 缓存计算值 useCallback 缓存组件 如果这样还是不够 那可能需要放在异步中处理 不要阻塞主线程 甚至你可以考虑放 web worker 中进行复杂运算 一个常见场景是计算上传文件的 MD5 值 对了 你使用的三方库 plugin 之类的 也要关注业界方向 比如用 dayjs 替换 momentjs 用体积更小 性能更好的库 跟上社区的步伐 没用的东西趁早删掉 避免屎山形成 接下来在渲染层面 我们常用的优化手段主要就是懒加载 比如树节点的分层懒加载 表格的分页懒加载 图片位于可视区域后懒加载 iframe 懒加载等 虚拟列表 树和表格的虚拟列表 然后关于重排重绘的一系列注意事项 比如哪些会触发重排 修改 DOM 内容 位置 尺寸 增删DOM 可视窗口变化 手动读取部分布局属性 重绘 修改文本颜色 透明度啥的 最佳实践有哪些 比如在重绘重排后 避免立即读取部分布局属性 避免强制同步 避免分多条操作 DOM 样式属性 可以合并成一条 加 class 上去 如果需要基于旧样式算出新样式再变更的话 注意读写分离 可以利用一些特殊的属性 开启合成层的渲染 比如 transform opacity 等 针对特殊的动画 DOM 可以使用 will change 属性 以及提前脱离常规文档流 避免影响其它元素布局 针对复杂操作 先把 DOM display none 等操作完之后 再设置 display block 就行了 只需要两次重排重绘 针对某些特殊业务场景 比如发布会需要用到的超大流量宣传页面 可以只关注核心业务 只提供最基础的功能 使用静态页面展示 最后在用户体验上来看 怎么让用户 觉得 系统快 也是需要关注的点 比如全局 loading 效果的设计 骨架屏的设计 都是可以做很多实践 接下来 我想聊聊自动化的部分 突然发现大学学的自动化专业 仿佛要派上用场了 程序从自身上来说没有任何价值 是使用这个程序的人 解决了某个问题 从而产生了社会价值 才让这个程序变得有价值了 而我们在构建一个程序的时候 必然是希望我们只关注核心的业务难点 其它地方最好有人帮我兜住 在我们雇得起帮手之前 先考虑下 其它地方 的部分 能不能也通过程序实现 自动化 从开发流程来说 我们往往会经过 需求评审 方案设计 方案评审 工时预估和任务分配 实际开发联调 转测验证 发布上线 这样一条路线 那我们将重点关注 转测 发布上线 这块 不知道你有遇到多少次由于刷错包导致的测试环境事故甚至生产环境事故 往事不堪回首 细节不谈 我始终相信凡是需要人来处理的地方 都必然会出错 那么我们可以把哪些 重复性 事务性 的工作自动化呢 你的代码写好之后 肯定要打包后才能部署 那这里重要的两步 打包 和 部署 就是我们最先处理的部分 打包其实很简单 使用流水线工具 自动执行你已经在 package json 中定义好的命令 亦或是你自己写好的脚本 尤其需要依靠外部工具传值的时候 例如需要外部指定对应的打包环境 有了出好的包 那么部署当然也应该自动完成 在 github actions 结合 vercel 就可以轻松实践 到了真实的商业项目中 就要看选用什么平台 总体上没有太明显的差异 如果真的搞不定的话 尽快求助运维同事吧 别一不小心把环境搞崩了 如果从最理想的角度来看 我们希望软件随着时间是逐步进化的 那么如果我们能在解决线上问题 新需求验证完毕的第一时间就可以实时上线的话 那对于用户来说必然是最好的体验 但在实际操作中 这是一个 梦幻模式 先不说让用户 无感升级 的工程复杂性 如何保证频繁迭代上线情况下的工程质量 是一个很大的问题 从前端的角度来说 我写的代码必然没有 bug bushi 实际上大家只要干过活都知道 bug 其实是无处不在的 它可能来源于开发 产品 测试之间对需求的理解不一致 也可能是在新增 修改 删除代码的过程中 出现了意料之外的问题 尤其是影响到你完全没关注的地方 这是非常危险的 那么如何在交给测试验收之前 我们就做好自验证呢 从我的实践来说 针对工具类型函数的单元测试 以及需求完成 bug修复后的集成测试是必须完成的事 关于测试 有时候参加测试用例评审 你可能会觉得哎呀耽误我写代码了 但我真的遇到过一个令我 膜拜 的测试人员 她的测试用例评审往往都是耗时最长 也最为详尽 会议争论最多的会议 为什么会这样呢 其实我仔细想来 那位测试同事做的事 我总结为 从用户角度出发看效果 从开发角度出发看实现 从产品运营角度看价值 对于一个新的需求 其实测试最直观看到的 就是前端的页面 支持了哪些功能 用起来好不好用 虽说在产品方案设计评审时 大家都已经参与过一波讨论了 但在实践的过程中 大家总会再提出一些新的疑问 观点 目的都是为了有更好的用户体验 而 用户体验 是一个抽象的概念 而一个资深测试 会把它具化为无数的细节 思产品所不曾思 想设计所不曾想 可能他们只需要简单提出几个问题 你就知道他们的功力深厚了 接下来是从开发角度看实现 一个功能的实现可能有无数种方法 那么选取的方法究竟是不是当前的最优解 如果执行的话 会不会对原有系统造成冲击 说起来这些是SE和具体开发关注的点 但测试也会从项目架构以及实际业务的角度 提出建设性意见 最后的看价值环节 最为精彩 我见过多次 由测试或者开发 从功能 方案 投入产出比等角度深入分析 最终告诉所有人 当前大家别再继续了 有坑 我相信最终如果大家真的达成这个结论 那将是一个巨大的价值 有点跑题了 其实我想表达的是 在自动化测试上面 做是一定要做的 不光是为了快速验证功能 保证代码质量 更是为了后续代码的重构 优化奠定一个良好的基础 至于具体是开发主导还是测试主导 就要考虑当前团队成员的背景情况 大家一起合力输出 定好标准 写好用例 使用自动化的手段把代码看护好 最后 我想聊聊监控平台 还是上文提到的观点 没有反馈就没有控制 我们的系统 想要长期稳定运行 就必然要要配备一个 监护人 也就是监控平台 它最基础的功能 就是帮我们统计用户在现网环境下使用时 出现了哪些错误 比如静态资源加载失败了 某个接口调用失败了 某个操作导致页面白屏等等 它需要详细记录用户出错时的所有上下文环境 以及完整的复现步骤 方便我们后续复现排查解决问题 在此基础上 我们还可以深入一些 针对重点关注的页面 它的性能表现如何 加载速度是符合用户预期的 还是低于预期的 性能上的卡点在哪里 是否需要进行深度优化 最后 还可以跟打点日志上报结合起来 看下用户日常最常用哪些功能 尤其是一个新功能上线之后 我们可以从数据里面看到这个功能是否被用户频繁使用 如果没有的话 是不是功能的入口隐藏的太深 页面上没有符合直觉的清晰引导 还是说这个功能就是一个低频功能 亦或者这个功能在用户看来很难用 试过一次之后就再也不想用了 有了数据的支撑 我们就可以明确下一步优化的方向 能做的事情还有很多 就像文章开头所说的那样 前端工程化是一个很大的话题 我只是把自己在实践过程中的一些想法写在这里 它是一个随着项目发展和团队成长而不断演进的持续过程 所以最好的方法可能是定期回顾流程中的瓶颈 并引入新的实践或工具进行优化 保证我们的 房子 能持久的盖下去"
  },
  {
    "id": "节流防抖",
    "title": "节流防抖",
    "summary": "什么是节流/防抖？防抖是延迟执行最后一次，节流是固定频率执行 1. 防抖：当用户在某一个时间段内，连续触发时，只在最后实际执行一次。比如我给表单的提交按钮，加了 1s 防抖，则用户如果在 1s 内点了 10 次，我也只在最后触发一次回调事件 2. 节流：当用户在某一个时间段内，连续触发时，限定它的触发频率。比如我给 scroll 监听事件加了 1s 节流，则用户在页面滚动过程中，不管他滚动的多快（...",
    "content": "什么是节流/防抖？防抖是延迟执行最后一次，节流是固定频率执行\n防抖：当用户在某一个时间段内，连续触发时，只在最后实际执行一次。比如我给表单的提交按钮，加了 1s 防抖，则用户如果在 1s 内点了 10 次，我也只在最后触发一次回调事件\n节流：当用户在某一个时间段内，连续触发时，限定它的触发频率。比如我给 scroll 监听事件加了 1s 节流，则用户在页面滚动过程中，不管他滚动的多快（scroll 触发的有多频繁），我们也是 1s 响应一次，触发回调事件\n如何实现？\n防抖/节流：\nLodash\n防抖用clearTimeout重置计时、节流用时间戳或定时器控制频率\n有啥用？\n防抖处理的是用户频繁触发，但实际只需要触发一次的场景（比如表单提交按钮，输入验证/搜索）\n节流处理的是用户频繁触发，但实际只需要以规定频率触发的场景（比如监听 scroll 滚动事件，射击游戏的连发限制）\n最佳实践？\n防抖延迟设300-500ms（输入场景），节流间隔设16ms（动画）或100ms（滚动）\n凡是用户可能频繁触发，但实际只需要触发一次的地方，都要加防抖处理\n防抖还可以配合后端接口一起处理，接口发送前，前端生成一个哈希值，作为参数传递给后端，当这个接口处理完毕后，再生成一个新的哈希值，替换之前的哈希值。如果服务端收到两个相同的哈希值，说明用户触发了重复请求，可以直接拒绝第二次请求，给出前端友好的提示信息。\n用Lodash库快速实现（如\\_.debounce(searchFunc, 500)），避免重复造轮子",
    "tags": [
      "throttle",
      "debounce",
      "JavaScript"
    ],
    "date": "2025-10-21",
    "readingTime": "3 min read",
    "url": "/blog/节流防抖",
    "searchText": "节流防抖 什么是节流 防抖 防抖是延迟执行最后一次 节流是固定频率执行 防抖 当用户在某一个时间段内 连续触发时 只在最后实际执行一次 比如我给表单的提交按钮 加了 1s 防抖 则用户如果在 1s 内点了 10 次 我也只在最后触发一次回调事件 节流 当用户在某一个时间段内 连续触发时 限定它的触发频率 比如我给 scroll 监听事件加了 1s 节流 则用户在页面滚动过程中 不管他滚动的多快 scroll 触发的有多频繁 我们也是 1s 响应一次 触发回调事件 如何实现 防抖 节流 Lodash 防抖用clearTimeout重置计时 节流用时间戳或定时器控制频率 有啥用 防抖处理的是用户频繁触发 但实际只需要触发一次的场景 比如表单提交按钮 输入验证 搜索 节流处理的是用户频繁触发 但实际只需要以规定频率触发的场景 比如监听 scroll 滚动事件 射击游戏的连发限制 最佳实践 防抖延迟设300 500ms 输入场景 节流间隔设16ms 动画 或100ms 滚动 凡是用户可能频繁触发 但实际只需要触发一次的地方 都要加防抖处理 防抖还可以配合后端接口一起处理 接口发送前 前端生成一个哈希值 作为参数传递给后端 当这个接口处理完毕后 再生成一个新的哈希值 替换之前的哈希值 如果服务端收到两个相同的哈希值 说明用户触发了重复请求 可以直接拒绝第二次请求 给出前端友好的提示信息 用Lodash库快速实现 如 _ debounce searchFunc 500 避免重复造轮子"
  },
  {
    "id": "设计模式",
    "title": "设计模式",
    "summary": "单例模式 确保一个类只有一个实例，并提供全局访问点。保证了一个类只有一个实例。 解决了什么问题？ 保证全局唯一，避免数据状态混乱，节省资源。比如 modal 弹窗（只需要一个，最多替换里面的内容），比如文档编辑器示例（一个页面中只需要一个，允许操作这个示例），比如 Redux（只需要一个管理全局数据） 最佳实践： 1. ES6 导出的对象也是唯一的，无需手动实现单例 2. 实现的时候需要注意隐藏构...",
    "content": "单例模式\n确保一个类只有一个实例，并提供全局访问点。保证了一个类只有一个实例。\n解决了什么问题？\n保证全局唯一，避免数据状态混乱，节省资源。比如 modal 弹窗（只需要一个，最多替换里面的内容），比如文档编辑器示例（一个页面中只需要一个，允许操作这个示例），比如 Redux（只需要一个管理全局数据）\n最佳实践：\nES6 导出的对象也是唯一的，无需手动实现单例\n实现的时候需要注意隐藏构造函数（防止随便 new），通过统一的入口比如 getInstance 处理\n多线程环境下可能破坏唯一性（如两个线程同时创建实例），需补充“双检锁”等解决方案，浏览器由于是单线程的，不用考虑此问题\n发布订阅模式\n通过事件调度中心（Event Bus）实现发布者和订阅者的解耦\n解决了什么问题？\n可以通过 event 实例，跨组件传递数据（在需要接收数据的地方，监听事件。在需要发送数据的地方，触发事件），无需耦合在一起，需要设计消息确认机制（避免消息丢失）\n最佳实践：\n需首先保证 event 实例全局唯一\n不可滥用事件传递，过多使用可能导致数据流混乱，难以排查问题\n一个简单的事件调度中心（Event Bus）实现：搞一个 WeakMap，当有人注册事件监听的时候，就存入 WeakMap 中，当有人触发事件，则在 WeakMap 里面找到对应事件的回调函数并执行，如果要注销事件监听，就把 Map 中对应事件的回调函数删除\n注意取消订阅，避免内存泄露\n工厂模式\n通过将对象的创建和使用分离，将对象的创建过程封装在工厂类中，使用者只需传参，无需关心对象构建细节。\n解决了什么问题？\n适用于需要批量创建多个类似的复杂对象（比如按钮，表单）\n最佳实践\n如果所需对象简单且仅需使用一次，则没必要必须使用工厂模式\n策略模式\n将算法封装成可互换的\"技能包\"，运行时动态切换。\n解决了什么问题？\n在不改变对象本身的情况下，通过修改内部的逻辑，实现对不同场景的适配。\n最佳实践：\n常用来替换复杂的 if/else 嵌套场景，让策略独立于主逻辑（比如支付方式的选择）\n责任链模式\n将多个处理器串联成链，请求沿链传递，直到有处理器处理\n解决了什么问题？\n如果一个请求与多个请求处理者混合在一起，则会出现混乱。可以将所有请求的处理者通过前一对象记住下一对象的方式形成一条链，然后将请求沿着链传递，直到有一个对象处理它为止。比如在 ",
    "tags": [
      "design"
    ],
    "date": "2025-10-22",
    "readingTime": "5 min read",
    "url": "/blog/设计模式",
    "searchText": "设计模式 单例模式 确保一个类只有一个实例 并提供全局访问点 保证了一个类只有一个实例 解决了什么问题 保证全局唯一 避免数据状态混乱 节省资源 比如 modal 弹窗 只需要一个 最多替换里面的内容 比如文档编辑器示例 一个页面中只需要一个 允许操作这个示例 比如 Redux 只需要一个管理全局数据 最佳实践 ES6 导出的对象也是唯一的 无需手动实现单例 实现的时候需要注意隐藏构造函数 防止随便 new 通过统一的入口比如 getInstance 处理 多线程环境下可能破坏唯一性 如两个线程同时创建实例 需补充 双检锁 等解决方案 浏览器由于是单线程的 不用考虑此问题 发布订阅模式 通过事件调度中心 Event Bus 实现发布者和订阅者的解耦 解决了什么问题 可以通过 event 实例 跨组件传递数据 在需要接收数据的地方 监听事件 在需要发送数据的地方 触发事件 无需耦合在一起 需要设计消息确认机制 避免消息丢失 最佳实践 需首先保证 event 实例全局唯一 不可滥用事件传递 过多使用可能导致数据流混乱 难以排查问题 一个简单的事件调度中心 Event Bus 实现 搞一个 WeakMap 当有人注册事件监听的时候 就存入 WeakMap 中 当有人触发事件 则在 WeakMap 里面找到对应事件的回调函数并执行 如果要注销事件监听 就把 Map 中对应事件的回调函数删除 注意取消订阅 避免内存泄露 工厂模式 通过将对象的创建和使用分离 将对象的创建过程封装在工厂类中 使用者只需传参 无需关心对象构建细节 解决了什么问题 适用于需要批量创建多个类似的复杂对象 比如按钮 表单 最佳实践 如果所需对象简单且仅需使用一次 则没必要必须使用工厂模式 策略模式 将算法封装成可互换的 技能包 运行时动态切换 解决了什么问题 在不改变对象本身的情况下 通过修改内部的逻辑 实现对不同场景的适配 最佳实践 常用来替换复杂的 if else 嵌套场景 让策略独立于主逻辑 比如支付方式的选择 责任链模式 将多个处理器串联成链 请求沿链传递 直到有处理器处理 解决了什么问题 如果一个请求与多个请求处理者混合在一起 则会出现混乱 可以将所有请求的处理者通过前一对象记住下一对象的方式形成一条链 然后将请求沿着链传递 直到有一个对象处理它为止 比如在 ai 对话的解析场景中 接口返回的内容中 包含了 messageType 字段 用来做场景区分 前端拆分出多个对应的 handler 责任独立 让接口返回的内容一层层沿着 handler 传递 直到出现匹配的 handler 进行处理 最佳实践 需要注意实际业务中 责任链的顺序是否会影响业务逻辑 最好设计成无影响的 有利于后期拓展和维护 如果出现链中无处理者时 需要设计兜底的默认逻辑"
  },
  {
    "id": "重排重绘",
    "title": "重排重绘",
    "summary": "浏览器的重绘重排，指的是当 DOM 和 CSSOM 被修改后，可能会重新触发浏览器渲染的关键路径和。 1. 重排：当 DOM 元素的变化影响了它的几何属性（大小，位置，布局），浏览器需要重新计算元素的几何属性，并重新构建文档树的全部或部分过程 2. 重绘：当 DOM 元素属性的变化不影响它在文档流中的位置和大小时，浏览器需要重新绘制元素外观。    重排必定导致重绘，因为布局变化后需要重新绘制。而...",
    "content": "浏览器的重绘重排，指的是当 DOM 和 CSSOM 被修改后，可能会重新触发浏览器渲染的关键路径和。\n重排：当 DOM 元素的变化影响了它的几何属性（大小，位置，布局），浏览器需要重新计算元素的几何属性，并重新构建文档树的全部或部分过程\n重绘：当 DOM 元素属性的变化不影响它在文档流中的位置和大小时，浏览器需要重新绘制元素外观。\n   重排必定导致重绘，因为布局变化后需要重新绘制。而重绘不一定导致重排，因为布局可能未发生变化\n什么情况下会触发重排？\n可见 DOM 元素的增删\n元素素位置、尺寸变化（宽度、高度、边距、填充、边框等）\n元素内容变化（文本变化，图片变化）\n浏览器可视窗口变化\n计算某些布局信息（如offsetTop、getComputedStyle等方法）\n什么情况下会触发重绘？\n修改了 DOM 元素的外观属性，比如颜色，透明度，阴影，边框样式\n重排重绘会导致什么问题？\n消耗资源，造成卡顿\n影响页面交互的流畅度，如果JavaScript执行、重排、重绘的时间总和超过16.67毫秒（60fps 屏幕），就会导致帧率下降，动画和滚动等交互效果会变得不流畅。\n有哪些手段可以避免重排重绘？（最佳实践）\n尽量避免在重排重绘后，立即读取一些布局属性，此时会打断浏览器本身的批量处理优化，强制同步布局，立即进行重排，造成强制同步布局\n在修改 DOM 时，进行批量的写入和读取（比如先通过虚拟 DOM 做对比，计算出真实 DOM 需要更新的最小集合，再执行真实的 DOM 操作\n在写入样式时，一次性完整写入，且做到读写分离\n避免对样式的频繁操作\n利用特殊的样式属性，比如 transform，opacity，使用合成层更新，开启 GPU 加速。使用 will-change 属性（仅针对复杂动画），提示浏览器将要发生变化。\n使用变量对布局信息进行缓存，避免频繁读取导致的重排\n使动画元素脱离普通文档流（position：fixed，absolute），避免影响其他元素的布局\n避免 table 布局，只要有一个单元格改动，就会造成整个表格重排\n对于复杂操作，可先将元素display设为none，操作完成后再显示，这样只在隐藏和显示时触发两次重排",
    "tags": [
      "layout",
      "paint",
      "CSS"
    ],
    "date": "2025-10-21",
    "readingTime": "4 min read",
    "url": "/blog/重排重绘",
    "searchText": "重排重绘 浏览器的重绘重排 指的是当 DOM 和 CSSOM 被修改后 可能会重新触发浏览器渲染的关键路径和 重排 当 DOM 元素的变化影响了它的几何属性 大小 位置 布局 浏览器需要重新计算元素的几何属性 并重新构建文档树的全部或部分过程 重绘 当 DOM 元素属性的变化不影响它在文档流中的位置和大小时 浏览器需要重新绘制元素外观 重排必定导致重绘 因为布局变化后需要重新绘制 而重绘不一定导致重排 因为布局可能未发生变化 什么情况下会触发重排 可见 DOM 元素的增删 元素素位置 尺寸变化 宽度 高度 边距 填充 边框等 元素内容变化 文本变化 图片变化 浏览器可视窗口变化 计算某些布局信息 如offsetTop getComputedStyle等方法 什么情况下会触发重绘 修改了 DOM 元素的外观属性 比如颜色 透明度 阴影 边框样式 重排重绘会导致什么问题 消耗资源 造成卡顿 影响页面交互的流畅度 如果JavaScript执行 重排 重绘的时间总和超过16 67毫秒 60fps 屏幕 就会导致帧率下降 动画和滚动等交互效果会变得不流畅 有哪些手段可以避免重排重绘 最佳实践 尽量避免在重排重绘后 立即读取一些布局属性 此时会打断浏览器本身的批量处理优化 强制同步布局 立即进行重排 造成强制同步布局 在修改 DOM 时 进行批量的写入和读取 比如先通过虚拟 DOM 做对比 计算出真实 DOM 需要更新的最小集合 再执行真实的 DOM 操作 在写入样式时 一次性完整写入 且做到读写分离 避免对样式的频繁操作 利用特殊的样式属性 比如 transform opacity 使用合成层更新 开启 GPU 加速 使用 will change 属性 仅针对复杂动画 提示浏览器将要发生变化 使用变量对布局信息进行缓存 避免频繁读取导致的重排 使动画元素脱离普通文档流 position fixed absolute 避免影响其他元素的布局 避免 table 布局 只要有一个单元格改动 就会造成整个表格重排 对于复杂操作 可先将元素display设为none 操作完成后再显示 这样只在隐藏和显示时触发两次重排"
  },
  {
    "id": "闭包",
    "title": "闭包",
    "summary": "这篇我们来关注闭包 什么是闭包？ 闭包是由函数和它所在词法环境组合而成的实体，这个环境包含了闭包创建时，所能访问的所有局部变量。所以当外部函数已经执行完后，依然可以通过闭包（内部函数）访问到当时词法环境的变量。 如何创建闭包： 1. 存在函数嵌套（在外部函数中，再定义一个内部函数） 2. 内部函数使用了外部函数中的变量 3. 内部函数被导出，包括三种场景：(1)直接将内部函数作为返回值；(2)作为...",
    "content": "这篇我们来关注闭包\n什么是闭包？\n闭包是由函数和它所在词法环境组合而成的实体，这个环境包含了闭包创建时，所能访问的所有局部变量。所以当外部函数已经执行完后，依然可以通过闭包（内部函数）访问到当时词法环境的变量。\n如何创建闭包：\n存在函数嵌套（在外部函数中，再定义一个内部函数）\n内部函数使用了外部函数中的变量\n内部函数被导出，包括三种场景：(1)直接将内部函数作为返回值；(2)作为参数传递给其它变量；(3)被赋予给一个全局变量或对象的属性\n闭包有什么用？\n创建私有变量，实现数据封装。即在函数外部无法访问和修改函数内部定义的变量值，只能通过闭包提供的方法操作数据，有利于代码的安全性和模块化\n因为内部函数（闭包）持有对这些变量的引用，导致它们无法被垃圾回收机制回收，从而“延长”了其生命周期，对于需要记住上一次操作状态的场景非常有用，例如计数器，缓存函数\n解决异步编程中，避免因变量共享导致的问题。例如在循环中处理异步事件（如setTimeout），使用 var 声明变量时，会出现打印值始终是最后一次的值的问题。当使用 let 或 立即执行函数，在每一次循环都创建独立的作用域后，就可以解决这个问题\n最佳实践是什么？\n警惕内存泄露：在闭包使用完成后，需要手动解除引用，将引用的值指向 null\n在事件监听，定时器场景下，也要注意及时清理\n闭包捕获的是变量的引用，所以如果在闭包创建后，执行之前值发生了修改，最后闭包访问到的会是最新的值。\n扩展内容\n立即执行函数(IIFE)与闭包的关系​：IIFE是如何通过创建独立作用域来解决循环中的变量共享问题的？\nlet与闭包的协同作用​：为什么使用let可以避免var的变量提升和函数级作用域问题，从而减少对闭包的依赖。\n现代JavaScript中的闭包应用​：闭包在React Hooks、模块化开发等现代框架中的实际应用。\n引申到内存泄露的排查方法有哪些",
    "tags": [
      "JavaScript",
      "IIFE"
    ],
    "date": "2025-10-20",
    "readingTime": "7 min read",
    "url": "/blog/闭包",
    "searchText": "闭包 这篇我们来关注闭包 什么是闭包 闭包是由函数和它所在词法环境组合而成的实体 这个环境包含了闭包创建时 所能访问的所有局部变量 所以当外部函数已经执行完后 依然可以通过闭包 内部函数 访问到当时词法环境的变量 如何创建闭包 存在函数嵌套 在外部函数中 再定义一个内部函数 内部函数使用了外部函数中的变量 内部函数被导出 包括三种场景 1 直接将内部函数作为返回值 2 作为参数传递给其它变量 3 被赋予给一个全局变量或对象的属性 闭包有什么用 创建私有变量 实现数据封装 即在函数外部无法访问和修改函数内部定义的变量值 只能通过闭包提供的方法操作数据 有利于代码的安全性和模块化 因为内部函数 闭包 持有对这些变量的引用 导致它们无法被垃圾回收机制回收 从而 延长 了其生命周期 对于需要记住上一次操作状态的场景非常有用 例如计数器 缓存函数 解决异步编程中 避免因变量共享导致的问题 例如在循环中处理异步事件 如setTimeout 使用 var 声明变量时 会出现打印值始终是最后一次的值的问题 当使用 let 或 立即执行函数 在每一次循环都创建独立的作用域后 就可以解决这个问题 最佳实践是什么 警惕内存泄露 在闭包使用完成后 需要手动解除引用 将引用的值指向 null 在事件监听 定时器场景下 也要注意及时清理 闭包捕获的是变量的引用 所以如果在闭包创建后 执行之前值发生了修改 最后闭包访问到的会是最新的值 扩展内容 立即执行函数 IIFE 与闭包的关系 IIFE是如何通过创建独立作用域来解决循环中的变量共享问题的 let与闭包的协同作用 为什么使用let可以避免var的变量提升和函数级作用域问题 从而减少对闭包的依赖 现代JavaScript中的闭包应用 闭包在React Hooks 模块化开发等现代框架中的实际应用 引申到内存泄露的排查方法有哪些"
  }
]